#!/usr/bin/wish 

#  Player - One Hell of a Robot Server
# Copyright (C) 2000  Brian Gerkey   &  Kasper Stoy
#                     gerkey@usc.edu    kaspers@robotics.usc.edu
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#
# $Id$
#
# a nifty Tk robot viewer
#

set PLAYER_VERSION 1.0-gamma

# for the 'signal' command
package require Tclx

# get the robot client utilities
if {[file exists ../../client_libs/tcl/playerclient.tcl]} {
  source ../../client_libs/tcl/playerclient.tcl
} else { 
  source /usr/local/player-${PLAYER_VERSION}/lib/playerclient.tcl
}

set CANVAS_WIDTH 400
set CANVAS_HEIGHT 400
set PI 3.14159264

# max range of 8 meters
set MAX_RANGE 8000.0

 
set host $PLAYER_DEFAULT_HOST
set port $PLAYER_DEFAULT_PORT

set ACTS_CHANNELS {red green blue magenta yellow cyan}

set USAGE "USAGE: viewer.tk -- \[-h <host>\] \[-p <port>\] \[-s <size>\]\n  -h <host> : hostname/IP where Player is running (default: $host)\n  -p <port> : TCP port where Player is running (default: $port)\n -s <size> : width/height (in pixels) of the sensor display (default: $CANVAS_HEIGHT)"

# this will be our robot object
array set robot {}
       
set i 0
while {$i < $argc} {
  if {![string compare [lindex $argv $i] "-h"]} {
    incr i
    if {$i == $argc} {
      puts $USAGE 
      exit 1
    }
    set host [lindex $argv $i]
  } elseif {![string compare [lindex $argv $i] "-p"]} {
    incr i
    if {$i == $argc} {
      puts $USAGE 
      exit 1
    }
    set port [lindex $argv $i]
  } elseif {![string compare [lindex $argv $i] "-s"]} {
    incr i
    if {$i == $argc} {
      puts $USAGE 
      exit 1
    }
    set CANVAS_HEIGHT [lindex $argv $i]
    set CANVAS_WIDTH [lindex $argv $i]
  } else {
    puts $USAGE
    exit 1
  }
  incr i
}

# we'll multiply values in mm by this in order to display them
set CANVAS_CONV_FACTOR [expr ($CANVAS_HEIGHT / 2.0)  / $MAX_RANGE]

# precompute trig operations on laser angles
# saves lots of time later
array set laser_angles {}
set i 0
while {$i < 721} {
  set laser_angles($i,cos) [expr cos(((-90 + ($i * 0.25)) * $PI) / 180.0)]
  set laser_angles($i,sin) [expr sin(((-90 + ($i * 0.25)) * $PI) / 180.0)]
  incr i
}


# from the ActivMedia specs, these are the positions of the sonars (and thus
# the border of the robot)
array set sonar_positions [list\
  0,x  -130 0,y  -115 0,theta   90\
  1,x  -115 1,y  -155 1,theta   50\
  2,x   -80 2,y  -190 2,theta   30\
  3,x   -25 3,y  -210 3,theta   10\
  4,x    25 4,y  -210 4,theta  -10\
  5,x    80 5,y  -190 5,theta  -30\
  6,x   115 6,y  -155 6,theta  -50\
  7,x   130 7,y  -115 7,theta  -90\
  8,x   130 8,y   115 8,theta  -90\
  9,x   115 9,y   155 9,theta -130\
  10,x   80 10,y  190 10,theta -150\
  11,x   25 11,y  210 11,theta -170\
  12,x  -25 12,y  210 12,theta  170\
  13,x  -80 13,y  190 13,theta  150\
  14,x -115 14,y  155 14,theta  130\
  15,x -130 15,y  115 15,theta   90]

# precompute trig operations on sonar angles
# saves lots of time later
array set sonar_angles {}
set i 0
while {$i < $PLAYER_NUM_SONAR_SAMPLES}  {
  set sonar_angles($i,cos) \
    [expr cos((($sonar_positions($i,theta) * $PI)/180.0))]
  set sonar_angles($i,sin) \
    [expr sin((($sonar_positions($i,theta) * $PI)/180.0))]
  incr i
}

#########################################################################
# these toggle_* procs are called when the corresponding checkbuttons
# are pressed.  they open and close the appropriate device
#
proc toggle_vision {} {
  global display_vision
  if {$display_vision} {
    player_req_dev robot vision r
  } else {
    player_req_dev robot vision c
  }
}
proc toggle_sonar {} {
  global display_sonar
  if {$display_sonar} {
    player_req_dev robot sonar r
    player_change_sonar_state robot 1
  } else {
    player_req_dev robot sonar c
    player_change_sonar_state robot 0
  }
}
proc toggle_laser {} {
  global display_laser display_lb
  if {$display_laser} {
    player_req_dev robot laser r
  } else {
    if {$display_lb} {
      set display_lb 0
      toggle_lb
    }
    player_req_dev robot laser c
  }
}
proc toggle_lb {} {
  global display_lb display_laser
  if {$display_lb} {
    if {!$display_laser} {
      set display_laser 1
      toggle_laser
    }
    player_req_dev robot laserbeacon r
  } else {
    player_req_dev robot laserbeacon c
  }
}
proc toggle_motor_state {} {
  global motor_state

  player_change_motor_state robot $motor_state
}
#########################################################################

#########################################################################
# following are definitions for the arrow bitmaps used on the control
# buttons
#
set leftarrow [image create bitmap -data \
 "#define leftarrow_width 12 #define leftarrow_height 12 static char leftarrow_bits[] = { 0x80,0x00,0xc0,0x00,0xe0,0x00,0xf0,0x00,0xf8,0x00,0xfc,0x00,0xfc,0x00,0xf8, 0x00,0xf0,0x00,0xe0,0x00,0xc0,0x00,0x80,0x00};"]
set rightarrow [image create bitmap -data \
 "#define rightarrow_width 12 #define rightarrow_height 12 static char rightarrow_bits[] = { 0x10,0x00,0x30,0x00,0x70,0x00,0xf0,0x00,0xf0,0x01,0xf0,0x03,0xf0,0x03,0xf0, 0x01,0xf0,0x00,0x70,0x00,0x30,0x00,0x10,0x00};"]
set uparrow [image create bitmap -data \
 "#define uparrow_width 12 #define uparrow_height 12 static char uparrow_bits[] = { 0x00,0x00,0x00,0x00,0x60,0x00,0xf0,0x00,0xf8,0x01,0xfc,0x03,0xfe,0x07,0xff, 0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};"]
set downarrow [image create bitmap -data \
  "#define downarrow_width 12 #define downarrow_height 12 static char downarrow_bits[] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x0f,0xfe,0x07,0xfc,0x03,0xf8, 0x01,0xf0,0x00,0x60,0x00,0x00,0x00,0x00,0x00};"]
#########################################################################

set moving 0
# move the robot
proc moveRobot {x y} {
  global moving
  set maxtv 500.0
  set maxrv 80.0

  if {$moving} {
    set tv [expr $maxtv * ($y / 100.0)]
    set rv [expr $maxrv * ($x / 100.0)]
    player_set_speed robot $tv $rv
  }
}

proc createControlPanel {} {
  global motor_state moving
  set size 100

  frame .control_panel

  canvas .control_panel.pcontrol -height $size -width $size -bg black \
       -xscrollincrement 1 -yscrollincrement 1
  # center the origin (it starts in the top left corner)
  .control_panel.pcontrol xview scroll -[expr round($size / 2.0)] units
  .control_panel.pcontrol yview scroll -[expr round($size / 2.0)] units

  # draw the axes
  .control_panel.pcontrol create line -[expr round($size / 2)] 0 \
                                       [expr round($size / 2)] 0 \
                                       -fill red
  .control_panel.pcontrol create line 0 -[expr round($size / 2)] 0 \
                                         [expr round($size / 2)] \
                                         -fill red

  # for safety
  bind .control_panel.pcontrol <Leave> \
    {catch {player_stop_robot robot; set moving 0}}
  bind .control_panel.pcontrol <ButtonRelease-1> \
    {catch {player_stop_robot robot; set moving 0}}

  # to control motion 
  bind .control_panel.pcontrol <Button-1> \
    {set moving 1;moveRobot [expr -%x + 50] [expr -%y + 50]}
  bind .control_panel.pcontrol <Motion> \
    {moveRobot [expr -%x + 50] [expr -%y + 50]}

  checkbutton .control_panel.motor_state -text "Activate Motors" \
                -variable motor_state -command toggle_motor_state

  set motor_state 0

  grid configure .control_panel.pcontrol -column 0 -row 0

  grid configure .control_panel.motor_state -column 0 -row 1
}

proc createStatusPanel {} {
  global robot

  frame .status_panel

  label .status_panel.time_sec -text "Time (sec):"
  label .status_panel.time_value_sec -textvariable robot(time_sec) -width 10 -anchor e
  label .status_panel.time_usec -text "       (usec):"
  label .status_panel.time_value_usec -textvariable robot(time_usec) -width 10 -anchor e
  label .status_panel.xpos -text X:
  label .status_panel.xpos_value -textvariable robot(position,xpos) -width 10 -anchor e
  label .status_panel.ypos -text Y:
  label .status_panel.ypos_value -textvariable robot(position,ypos) -width 10 -anchor e
  label .status_panel.heading -text Heading:
  label .status_panel.heading_value -textvariable robot(position,heading) -width 10 -anchor e
  label .status_panel.compass -text Compass:
  label .status_panel.compass_value -textvariable robot(position,compass) -width 10 -anchor e
  label .status_panel.battery -text Battery:
  label .status_panel.battery_value -textvariable robot(misc,battery) -width 10 -anchor e
  label .status_panel.stall -text Stall:
  label .status_panel.stall_value -textvariable robot(position,stall) -width 10 -anchor e

  grid configure .status_panel.time_sec -column 0 -row 0 -sticky w
  grid configure .status_panel.time_value_sec -column 1 -row 0 -sticky w
  grid configure .status_panel.time_usec -column 0 -row 1 -sticky w
  grid configure .status_panel.time_value_usec -column 1 -row 1 -sticky w
  grid configure .status_panel.xpos -column 0 -row 2 -sticky w
  grid configure .status_panel.xpos_value -column 1 -row 2 -sticky w
  grid configure .status_panel.ypos -column 0 -row 3 -sticky w
  grid configure .status_panel.ypos_value -column 1 -row 3 -sticky w
  grid configure .status_panel.heading -column 0 -row 4 -sticky w
  grid configure .status_panel.heading_value -column 1 -row 4 -sticky w
  grid configure .status_panel.compass -column 0 -row 5 -sticky w
  grid configure .status_panel.compass_value -column 1 -row 5 -sticky w
  grid configure .status_panel.battery -column 0 -row 6 -sticky w
  grid configure .status_panel.battery_value -column 1 -row 6 -sticky w
  grid configure .status_panel.stall -column 0 -row 7 -sticky w
  grid configure .status_panel.stall_value -column 1 -row 7 -sticky w
}

set newpan 0
set newtilt 0
set newzoom 0

proc checkCameraLimits {} {
  global newpan newtilt newzoom
  set PAN_LOW_LIMIT -100
  set PAN_HIGH_LIMIT 100
  set TILT_LOW_LIMIT -25
  set TILT_HIGH_LIMIT 25
  set ZOOM_LOW_LIMIT 0
  set ZOOM_HIGH_LIMIT 1023
  
  if {$newpan > $PAN_HIGH_LIMIT} {set newpan $PAN_HIGH_LIMIT}
  if {$newpan < $PAN_LOW_LIMIT} {set newpan $PAN_LOW_LIMIT}
  if {$newtilt > $TILT_HIGH_LIMIT} {set newtilt $TILT_HIGH_LIMIT}
  if {$newtilt < $TILT_LOW_LIMIT} {set newtilt $TILT_LOW_LIMIT}
  if {$newzoom > $ZOOM_HIGH_LIMIT} {set newzoom $ZOOM_HIGH_LIMIT}
  if {$newzoom < $ZOOM_LOW_LIMIT} {set newzoom $ZOOM_LOW_LIMIT}
}

proc createVisionPanel {} {
  global display_vision leftarrow rightarrow uparrow downarrow
  global newpan newtilt newzoom
  global robot

  frame .vision_panel

  canvas .vision_panel.canvas -width 160 -height 120 -bg black

  checkbutton .vision_panel.vision_check -command toggle_vision\
    -variable display_vision -text "Display Vision"

  set display_vision 0

  button .vision_panel.left -image $leftarrow 
  button .vision_panel.right -image $rightarrow
  button .vision_panel.up -image $uparrow
  button .vision_panel.down -image $downarrow 

  button .vision_panel.in -text +
  button .vision_panel.out -text -

  frame .vision_panel.data_frame
  label .vision_panel.data_frame.pan -text Pan:
  label .vision_panel.data_frame.pan_value -textvariable robot(ptz,pan) -width 8 -anchor e
  label .vision_panel.data_frame.tilt -text Tilt:
  label .vision_panel.data_frame.tilt_value -textvariable robot(ptz,tilt) -width 8 -anchor e
  label .vision_panel.data_frame.zoom -text Zoom:
  label .vision_panel.data_frame.zoom_value -textvariable robot(ptz,zoom) -width 8 -anchor e

  bind .vision_panel.left <Button-1> \
    {catch {incr newpan 10;checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}
  bind .vision_panel.right <Button-1>\
    {catch {incr newpan -10;checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}
  bind .vision_panel.up <Button-1> \
    {catch {incr newtilt 5; checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}
  bind .vision_panel.down <Button-1> \
    {catch {incr newtilt -5;checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}
  bind .vision_panel.in <Button-1> \
    {catch {incr newzoom 100;checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}
  bind .vision_panel.out <Button-1> \
    {catch {incr newzoom -100;checkCameraLimits;player_set_camera robot $newpan $newtilt $newzoom}}

  grid configure .vision_panel.canvas -column 0 -row 0 -columnspan 5
  grid configure .vision_panel.vision_check -column 0 -row 1 -columnspan 5

  grid configure .vision_panel.left -column 0 -row 3
  grid configure .vision_panel.right -column 2 -row 3
  grid configure .vision_panel.up -column 1 -row 2
  grid configure .vision_panel.down -column 1 -row 4

  grid configure .vision_panel.in -column 3 -row 3
  grid configure .vision_panel.out -column 4 -row 3

  grid configure .vision_panel.data_frame -column 0 -row 5 -columnspan 5
  grid configure .vision_panel.data_frame.pan -column 0 -row 0 
  grid configure .vision_panel.data_frame.pan_value -column 1 -row 0
  grid configure .vision_panel.data_frame.tilt -column 0 -row 1
  grid configure .vision_panel.data_frame.tilt_value -column 1 -row 1
  grid configure .vision_panel.data_frame.zoom -column 0 -row 2
  grid configure .vision_panel.data_frame.zoom_value -column 1 -row 2
}

set display_sonar 0
set display_laser 0
set display_bumpers 0
set display_lb 0

proc createRobotPanel {} {
  global display_sonar display_laser CANVAS_WIDTH CANVAS_HEIGHT
  global display_bumpers MAX_RANGE CANVAS_CONV_FACTOR sonar_positions
  global display_lb

  frame .robot_panel

  # make a canvas to draw on
  canvas .robot_panel.canvas \
    -width [expr $CANVAS_WIDTH*1.1] \
    -height [expr $CANVAS_HEIGHT*1.1] \
    -xscrollincrement 1 -yscrollincrement 1 -bg black
  # center the origin (it starts in the top left corner)
  .robot_panel.canvas xview scroll -[expr round($CANVAS_WIDTH * 1.1 / 2)] units
  .robot_panel.canvas yview scroll -[expr round($CANVAS_HEIGHT * 1.1 / 2)] units

  # draw the robot
  .robot_panel.canvas create line \
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(0,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(0,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(1,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(1,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(2,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(2,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(3,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(3,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(4,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(4,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(5,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(5,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(6,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(6,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(7,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(7,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(8,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(8,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(9,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(9,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(10,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(10,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(11,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(11,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(12,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(12,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(13,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(13,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(14,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(14,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(15,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(15,y)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(0,x)]\
    [expr $CANVAS_CONV_FACTOR * $sonar_positions(0,y)]\
    -fill red

  # draw circles 1m apart
  set i 1000.0
  while {$i <= $MAX_RANGE} {
    set radius [expr $i * $CANVAS_CONV_FACTOR]
    .robot_panel.canvas create oval -$radius -$radius $radius $radius \
      -outline blue
    set i [expr $i + 1000.0]
  }

  checkbutton .robot_panel.sonar_check -command toggle_sonar\
    -variable display_sonar -text "Display Sonars"
  checkbutton .robot_panel.laser_check -command toggle_laser\
    -variable display_laser -text "Display Laser"
  checkbutton .robot_panel.lb_check -command toggle_lb \
    -variable display_lb -text "Display Laserbeacons"
  checkbutton .robot_panel.bumper_check \
    -variable display_bumpers -text "Display Bumpers"


  grid configure .robot_panel.canvas -column 0 -row 0 -columnspan 4
  grid configure .robot_panel.sonar_check -column 0 -row 1
  grid configure .robot_panel.laser_check -column 1 -row 1
  grid configure .robot_panel.lb_check -column 2 -row 1
  grid configure .robot_panel.bumper_check -column 3 -row 1
}

proc gridAll {} {
  grid configure .robot_panel -column 0 -row 0 -rowspan 3
  grid configure .control_panel -column 1 -row 0
  grid configure .status_panel -column 1 -row 1 
  grid configure .vision_panel -column 1 -row 2 
}

#
# helper proc to create the necessary widgets
#
proc go {} {
  createControlPanel
  createStatusPanel
  createRobotPanel
  createVisionPanel
  gridAll
}

#
# this was used to draw everything in the robot canvas, but now
# it's only used for the bumpers
#
proc drawobs {xoff yoff angle dist line_or_dot color} {
  global CANVAS_CONV_FACTOR PI

  set xoff [expr $xoff * $CANVAS_CONV_FACTOR]
  set yoff [expr $yoff * $CANVAS_CONV_FACTOR]
  set dist [expr $dist * $CANVAS_CONV_FACTOR]

  set theta [expr $angle * $PI / 180.0]
  set x [expr $xoff + -$dist * sin($theta)]
  set y [expr $yoff + -$dist * cos($theta)]

  if {$line_or_dot == "line"} {
    return [.robot_panel.canvas create line $xoff $yoff $x $y -fill $color]
  } else {
    return [.robot_panel.canvas create oval \
                             [expr $x - 4] [expr $y - 4] \
                             [expr $x + 4] [expr $y + 4] \
                             -fill $color]
  }
}

# a little helper to sort indices of the form "<foo>,<int>"
proc sort_readings {first second} {
  set index0 [lindex [split $first ,] end]
  set index1 [lindex [split $second ,] end]

  if {$index0 < $index1} {
    return -1
  } elseif {$index0 == $index1} {
    return 0
  } else {
    return 1
  }
}

set obslist {}
set vision_obslist {}
#
# this proc reads and displays one round of data.  an alarm goes off
# every 100ms or so and calls the proc
#
proc displayData {} {
  global sonar_positions display_sonar 
  global display_laser display_lb
  global display_bumpers 
  global display_vision
  global obslist vision_obslist
  global CANVAS_CONV_FACTOR PI
  global laser_angles sonar_angles
  global robot
  global ACTS_CHANNELS PI

  # read one round of data
  if {[catch {player_read robot} err]} {
    puts "Got error on read: $err"
    exit 1
  }

  # delete the old data from the display
  eval .robot_panel.canvas delete $obslist
  eval .vision_panel.canvas delete $vision_obslist

  set obslist {}
  set vision_obslist {}

  # length in mm from activmedia specs
  set BUMPER_LENGTH 100.838

  #
  # display the vision device data
  #
  if {$display_vision && [llength [array names robot vision,0,numblobs]]} {
    # draw the first n channels.
    set j 0
    while {$j < [llength $ACTS_CHANNELS]} {
      set i 0
      while {$i < $robot(vision,$j,numblobs)} {
        set vision_obslist [concat $vision_obslist \
          [.vision_panel.canvas create line \
                 $robot(vision,$j,$i,left)  $robot(vision,$j,$i,top)\
                 $robot(vision,$j,$i,right) $robot(vision,$j,$i,top)\
                 $robot(vision,$j,$i,right) $robot(vision,$j,$i,bottom)\
                 $robot(vision,$j,$i,left)  $robot(vision,$j,$i,bottom)\
                 $robot(vision,$j,$i,left)  $robot(vision,$j,$i,top) \
                 -width 2 -fill [lindex $ACTS_CHANNELS $j]]\
          [.vision_panel.canvas create polygon \
                 [expr $robot(vision,$j,$i,x) - 2] \
                 [expr $robot(vision,$j,$i,y) - 2] \
                 [expr $robot(vision,$j,$i,x) + 2] \
                 [expr $robot(vision,$j,$i,y) - 2] \
                 [expr $robot(vision,$j,$i,x) + 2] \
                 [expr $robot(vision,$j,$i,y) + 2] \
                 [expr $robot(vision,$j,$i,x) - 2] \
                 [expr $robot(vision,$j,$i,y) + 2] \
                 -fill [lindex $ACTS_CHANNELS $j]]]
        incr i
      }
      incr j
    }
  }
      
  #
  # display the bumper data (from the misc device)
  #
  if {$display_bumpers && [llength [array names robot misc,frontbumpers]]} {
    if {[expr $robot(misc,frontbumpers) >> 0 & 1]} {
      set obslist [concat $obslist \
        [drawobs -207.85 -152.01 -37.9904 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,frontbumpers) >> 1 & 1]} {
      set obslist [concat $obslist \
        [drawobs -145.8 -231.45 -71.1592 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,frontbumpers) >> 2 & 1]} {
      set obslist [concat $obslist \
        [drawobs -50.4 -264.0 -90 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,frontbumpers) >> 3 & 1]} {
      set obslist [concat $obslist \
        [drawobs 145.8 -231.45 71.1592 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,frontbumpers) >> 4 & 1]} {
      set obslist [concat $obslist \
        [drawobs 207.85 -152.01 37.9904 $BUMPER_LENGTH line yellow]]
    }

    if {[expr $robot(misc,rearbumpers) >> 4 & 1]} {
      set obslist [concat $obslist \
        [drawobs -207.85 152.01 -142.0096 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,rearbumpers) >> 3 & 1]} {
      set obslist [concat $obslist \
        [drawobs -145.8 231.45 -108.8408 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,rearbumpers) >> 2 & 1]} {
      set obslist [concat $obslist \
        [drawobs -50.4 264.0 -90 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,rearbumpers) >> 1 & 1]} {
      set obslist [concat $obslist \
        [drawobs 145.8 231.45 108.8408 $BUMPER_LENGTH line yellow]]
    }
    if {[expr $robot(misc,rearbumpers) >> 0 & 1]} {
      set obslist [concat $obslist \
        [drawobs 207.85 152.01 142.0096 $BUMPER_LENGTH line yellow]]
    }
  }

  #
  # display the sonar device data
  #
  if {$display_sonar} {
    set sonar_points {}
    foreach reading [lsort -command sort_readings \
                                   [array names robot sonar,*]] {
      set index [lindex [split $reading ,] end]
      # weed out non-integers
      if {[catch {expr $index + 1}]} {continue}
      set xoff [expr $sonar_positions($index,x) * $CANVAS_CONV_FACTOR]
      set yoff [expr $sonar_positions($index,y) * $CANVAS_CONV_FACTOR]
      set dist [expr $robot(sonar,$index) * $CANVAS_CONV_FACTOR]
    
      set x [expr $xoff + -$dist * $sonar_angles($index,sin)]
      set y [expr $yoff + -$dist * $sonar_angles($index,cos)]
    
      lappend sonar_points $x $y
    }
    # add the first point at the end to close the polygon
    set sonar_points [concat $sonar_points [lrange $sonar_points 0 1]]
    set obslist [concat $obslist \
      [eval .robot_panel.canvas create line $sonar_points -fill green]]
  }

  #
  # display the laser device data
  #
  if {$display_laser && [info exists robot(laser,range_count)]} {
    set laser_points [list 0 0]
    set index 0
    while {$index < $robot(laser,range_count)} {
      # correct for non-standard laser config
      set angle_index [expr round(((($robot(laser,min_angle) * 0.01) + 90)/0.25) + \
                            $index * (($robot(laser,resolution)*0.01)/0.25))]

      set dist [expr $robot(laser,$index) * $CANVAS_CONV_FACTOR]
      set x [expr -$dist * $laser_angles($angle_index,sin)]
      set y [expr -$dist * $laser_angles($angle_index,cos)]
    
      lappend laser_points $x $y
      incr index
    }

    lappend laser_points 0 0
    set obslist [concat $obslist \
      [eval .robot_panel.canvas create line $laser_points -fill red]]
  }

  # display the laser beacons
  if {$display_lb && [llength [array names robot laserbeacon,*]]} {
    set i 0
    while {$i < $robot(laserbeacon,numbeacons)} {
      # draw each beaon
      set bearing [expr (-$robot(laserbeacon,$i,bearing)-90.0)*$PI/180.0]
      set orient [expr (-$robot(laserbeacon,$i,orient)-90.0)*$PI/180.0]
      set dist [expr $robot(laserbeacon,$i,range) * $CANVAS_CONV_FACTOR]
      set x [expr $dist * cos($bearing)]
      set y [expr $dist * sin($bearing)]
      set xoff [expr 5.0 * cos($orient)]
      set yoff [expr 5.0 * sin($orient)]
      set obslist [concat $obslist \
        [.robot_panel.canvas create oval \
            [expr $x - 4.0] [expr $y - 4.0] \
            [expr $x + 4.0] [expr $y + 4.0] \
            -outline red] \
        [.robot_panel.canvas create text [expr $x+4] [expr $y+4] -anchor w \
            -text $robot(laserbeacon,$i,id) -fill red] \
        [.robot_panel.canvas create line [expr $x-$xoff] [expr $y-$yoff] \
                                         [expr $x+$xoff] [expr $y+$yoff] \
                                         -fill green]]
      incr i
    }
  }
}

proc startRobot {} {
  global host port 

  player_connect -reqrep robot $host $port

  # always try to connect to the position and misc devices
  if {[string compare [player_req_dev robot position a] a]} {
    puts "WARNING: unable to get access to the position device"
  }
  if {[string compare [player_req_dev robot misc r] r]} {
    puts "WARNING: unable to get access to the misc device"
  }
  if {[string compare [player_req_dev robot ptz a] a]} {
    puts "WARNING: unable to get access to the ptz device"
  }

  # -restart is VERY important....
  signal -restart trap SIGALRM {displayData;alarm .1}
  alarm .1
}

go
startRobot
