/*
 *  Player - One Hell of a Robot Server
 *  Copyright (C) 2000  
 *     Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
 *                      
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/*
 * $Id$
 *
 * the C++ client
 */

#ifndef PLAYERCLIENT_H
#define PLAYERCLIENT_H

#include <player.h>       /* from the server; gives message types */
#include <playercclient.h>  /* pure C networking building blocks */

#if HAVE_STRINGS_H
  #include <strings.h>
#endif

#include <sys/time.h>
//#include <sys/poll.h>
#include <string.h>

// Convert radians to degrees
//
#ifndef RTOD
#define RTOD(r) ((r) * 180 / M_PI)
#endif

// Convert degrees to radians
//
#ifndef DTOR
#define DTOR(d) ((d) * M_PI / 180)
#endif

// Normalize angle to domain -pi, pi
//
#ifndef NORMALIZE
#define NORMALIZE(z) atan2(sin(z), cos(z))
#endif

// forward declaration for friending
class PlayerClient;

/*****************************************************************************
 ** begin section ClientProxy
 *****************************************************************************/

/**
Base class for all proxy devices. Access to a device is provided by a
device-specific proxy class.  These classes all inherit from the {\tt
ClientProxy} class which defines an interface for device proxies.  As such,
a few methods are common to all devices and we explain them here.
*/
class ClientProxy
{
  friend class PlayerClient; // ANSI C++ syntax?

  public:         
     /** The controlling client object.
      */
    PlayerClient* client;

    // the last message header and body will be copied here by StoreData(), so
    // that it's available for later use.
    unsigned char last_data[PLAYER_MAX_MESSAGE_SIZE];
    player_msghdr_t last_header;

    unsigned char access;   // 'r', 'w', or 'a' (others?)
    //unsigned short robot;  // to which robot this proxy pertains
    //unsigned short device; // the name by which we identify this kind of device
    //unsigned short index;  // which device we mean
    player_device_id_t m_device_id;

    /** The name of the driver used to implement this device in the server.
     */
    char driver_name[PLAYER_MAX_DEVICE_STRING_LEN]; // driver in use

    /** Time at which this data was generated by the device. 
     */
    struct timeval timestamp;  

    /** Time at which this data was sent by the server. 
      */
    struct timeval senttime;   

    /** Time at which this data was received by the client. 
     */
    struct timeval receivedtime;

    /** This constructor will try to get access to the device,
        unless {\tt req_device} is 0 or {\tt req_access} is 'c'.
        The pointer {\tt pc} must refer to an already connected 
        {\tt PlayerClient} proxy.  The {\tt index} indicates which one of the
        devices to use (usually 0).  Note that a request executed by this
        the constructor can fail, but the constructor cannot indicate the
        failure.  Thus, if you request a particular access mode, you should 
        verify that the current access is identical to your requested access 
        using {\tt GetAccess()}.  In any case, you can use 
        {\tt ChangeAccess()} later to change your access mode for the device.
    */
    ClientProxy(PlayerClient* pc, 
		unsigned short req_device,
		unsigned short req_index,
		unsigned char req_access = 'c',
                unsigned short req_robot = 0);

    /*
    ClientProxy(PlayerClient* pc, 
		player_device_id_t device_id,
		unsigned char req_access = 'c' );
                */

    // destructor will try to close access to the device
    virtual ~ClientProxy();

    /**  Returns the current access mode for the device.
     */
    unsigned char GetAccess() { return(access); };  

    /** Request different access for the device.  If {\tt grant_access} is
        non-NULL, then it is filled in with the granted access.  Returns 0
        on success, -1 otherwise. */
    int ChangeAccess(unsigned char req_access, 
                     unsigned char* grant_access=NULL );

    /** Convenience method for requesting 'c' access.
     */
    int Close() { return(ChangeAccess('c')); }

    /** All proxies must provide this method.  It is used internally to parse
        new data when it is received. */
    virtual void FillData(player_msghdr_t hdr, const char* buffer);

    /** This method is used internally to keep a copy of the last message from
        the device **/
    void StoreData(player_msghdr_t hdr, const char* buffer);
    
    /** All proxies SHOULD provide this method, which should print out, in a
        human-readable form, the device's current state. */
    virtual void Print();
};

// keep a linked list of proxies that we've got open
class ClientProxyNode
{
  public:
    ClientProxy* proxy;
    ClientProxyNode* next;
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section PlayerClient
 *****************************************************************************/

/** One {\tt PlayerClient} object is used to control each connection to
    a Player server.  Contained within this object are methods for changing the
    connection parameters and obtaining access to devices, which we explain 
    next.
 */
class PlayerClient
{
  private:
    // special flag to indicate that we are being destroyed
    bool destroyed;

    // list of proxies associated with us
    ClientProxyNode* proxies;
    int num_proxies;

    int reserved;
    
    // get the pointer to the proxy for the given device and index
    //
    // returns NULL if we can't find it.
    //
    ClientProxy* GetProxy(unsigned short device, 
                                        unsigned short index);
    ClientProxy* GetProxy(player_device_id_t id);

  public:
    //  Struct containing information about the  connection to Player
    player_connection_t conn;

    // are we connected? 
    bool connected;

    void SetReserved(int res) { reserved = res; }
    int GetReserved() { return(reserved); }

    /** Flag set if data has just been read into this client.  If you
        use it, you must set it to false yourself after examining the data.
        */ 
    bool fresh; 

    /** The host of the Player server to which we are connected.
     */
    char hostname[256]; 

    /** The port of the Player server to which we are connected.
        */ 
    int port;
    
    // store the IP of the host, too - more efficient for
    // matching, etc, then the string
    struct in_addr hostaddr;

    /** The latest time received from the server.
       */
    struct timeval timestamp;

    // constructors
    
    /** Make a client and connect it as indicated.
        If {\tt hostname} is omitted (or NULL) then the client will {\em not}
        be connected.  In that cast, call {\tt Connect()} yourself later.
     */
    PlayerClient(const char* hostname=NULL, const int port=PLAYER_PORTNUM);

    /** Make a client and connect it as indicated, using a binary IP instead 
        of a hostname
      */
    PlayerClient(const struct in_addr* hostaddr, const int port);

    // destructor
    ~PlayerClient();

    /** Connect to the indicated host and port.\\
        Returns 0 on success; -1 on error.
     */
    int Connect(const char* hostname="localhost", int port=PLAYER_PORTNUM);

    /** Connect to the indicated host and port, using a binary IP.\\
        Returns 0 on success; -1 on error.
     */
    int Connect(const struct in_addr* addr, int port);

    /** Disconnect from server.\\
        Returns 0 on success; -1 on error.
      */
    int Disconnect();

    /** Check if we are connected.
      */
    bool Connected() { return((conn.sock >= 0) ? true : false); }

    /**
    This method will read one round of data; that is, it will read until a 
    SYNC packet is received from the server.  Depending on which data delivery
    mode is in use, new data may or may not be received for each open device.
    The data that is received for each device device will be processed by the
    appropriate device proxy and stored there for access by your program.
    If no errors occurred 0 is returned.  Otherwise, -1 is returned and
    diagnostic information is printed to {\tt stderr} (you should probably
    close the connection!).
    */
    int Read();
    
    /** Write a command to the server.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 on success, -1 otherwise. */
    int Write(player_device_id_t device_id,
              const char* command, size_t commandlen);

    /** Send a request to the server.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 on success, -1 otherwise. */
    int Request(player_device_id_t device_id,
                const char* payload,
                size_t payloadlen,
                player_msghdr_t* replyhdr,
                char* reply, size_t replylen);

    /** Another form of Request(), this one can be used if the caller is not
        interested in the reply.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 if an ACK is received, -1 
        otherwise. */
    int Request(player_device_id_t device_id,
                const char* payload,
                size_t payloadlen);
    
    /**
      Request access to a device; meant mostly for use by client-side device 
      proxy constructors.
      {\tt req_access} is requested access.
      {\tt grant_access}, if non-NULL, will be filled with the granted access.
      Returns 0 if everything went OK or -1 if something went wrong.
    */
    int RequestDeviceAccess(player_device_id_t device_id,
                            unsigned char req_access,
                            unsigned char* grant_access,
                            char* driver_name = NULL,
                            int driver_name_len = 0);

    // Player device configurations

    /**
      You can change the rate at which your client receives data from the 
      server with this method.  The value of {\tt freq} is interpreted as Hz; 
      this will be the new rate at which your client receives data (when in 
      continuous mode).  On error, -1 is returned; otherwise 0.
     */
    int SetFrequency(unsigned short freq);

    /** You can toggle the mode in which the server sends data to your 
        client with this method.  The {\tt mode} should be one of:
        \begin{itemize}
        \item {\tt PLAYER_DATAMODE_PUSH_ALL} (all data at fixed frequency)
        \item {\tt PLAYER_DATAMODE_PULL_ALL} (all data on demand)
        \item {\tt PLAYER_DATAMODE_PUSH_NEW} (only new new data at fixed freq)
        \item {\tt PLAYER_DATAMODE_PULL_NEW} (only new data on demand)
        \end{itemize}
        On error, -1 is returned; otherwise 0.
      */
    int SetDataMode(unsigned char mode);

    /** When in a {\tt PULL} data delivery mode, you can request a single 
        round of data using this method.  On error -1 is returned; otherwise 0.
      */
    int RequestData();

    /** Attempt to authenticate your client using the provided key.  If 
        authentication fails, the server will close your connection.
      */
    int Authenticate(char* key);
    
    // proxy list management methods

    // add a proxy to the list
    void AddProxy(ClientProxy* proxy);
    // remove a proxy from the list
    void RemoveProxy(ClientProxy* proxy);
};


/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PlayerMultiClient
 *****************************************************************************/

// forward declaration to avoid including <sys/poll.h>, which may not be
// available when people are building clients against this lib
struct pollfd;

/**
  The PlayerMultiClient makes it easy to control multiple Player connections 
  within one thread.   You can connect to any number of Player servers and
  read from all of them with a single {\tt Read()}.
  */
class PlayerMultiClient
{
  private:
    // dynamically managed array of our clients
    PlayerClient** clients;
    //int num_clients;
    int size_clients;

    // dynamically managed array of structs that we'll give to poll(2)
    struct pollfd* ufds;
    int size_ufds;
    int num_ufds;

  public:
    /** Uninteresting constructor. 
    */
    PlayerMultiClient();
    
    // destructor
    ~PlayerMultiClient();

    /** How many clients are currently being managed? 
     */
    int GetNumClients(void) { return num_ufds; };

    /** Return a pointer to the client associated with the given host and port,
        or NULL if none is connected to that address. */
    PlayerClient* GetClient( char* host, int port );

    /** Return a pointer to the client associated with the given binary host 
        and port, or NULL if none is connected to that address. */
    PlayerClient* GetClient( struct in_addr* addr, int port );
    
    /** After creating and connecting a PlayerClient object, you should use 
        this method to hand it over to the PlayerMultiClient for management.
        */
    void AddClient(PlayerClient* client);
    
    /** Remove a client from PlayerMultiClient management.
     */
    void RemoveClient(PlayerClient* client);

    /** Read on one of the client connections.  This method will return after 
        reading from the server with first available data.  It will {\bf
        not} read data from all servers.  You can use the {\tt fresh} flag
        in each client object to determine who got new data.  You should
        then set that flag to false.  Returns 0 if everything went OK,
        -1 if something went wrong. */
    int Read();

    /** Same as Read(), but reads everything off the socket so we end
        up with the freshest data, subject to N maximum reads. */
    int ReadLatest( int max_reads );
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section CommsProxy
 *****************************************************************************/

/** The {\tt CommsProxy} class controls a {\tt comms} device.
Data may be written one message at a time using the {\tt Write} method.  

Incoming data are stored in a set of parallel lists:
\begin{itemize}
\item {\tt uint8_t** msg} : list of pointers to message data
\item {\tt size_t* msg_len} : list of message lengths
\item {\tt struct timeval* msg_ts} : list of message timestamps
\end{itemize}
The current number of valid messages is stored in {\tt msg_num}, and so each 
list should be considered to be of length {\tt msg_num}.

To delete a message from the lists, use {\tt Delete()}.
*/
class CommsProxy : public ClientProxy
{
  /** Proxy constructor.  Leave the access field empty to start
      unconnected.  */
  public: CommsProxy(PlayerClient* pc, unsigned short index, 
                     unsigned char access ='c',unsigned short robot=0);

  public: ~CommsProxy();

  /** Write a message to the outgoing queue.
      Returns the number of bytes written, or -1 on error.
  */
  public: int Write(void *msg, int len);

  // interface that all proxies must provide
  protected: void FillData(player_msghdr_t hdr, const char* buffer);
  
  /// Delete the given message.  Returns 0 on success and -1 on error.
  public: int Delete(int index);
    
  /// Print out current message.
  public: void Print();

  /// List of received messages.
  public: uint8_t** msg;
  
  /// List of lengths of the received messages.
  public: size_t* msg_len;
  
  /// List of timestamps of the received messages.
  public: struct timeval* msg_ts;

  /// Number of received messages 
  public: size_t msg_num;

  // Current allocated length of msg and msg_len
  private: size_t listlen;
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


class DescartesProxy : public ClientProxy
{

  public:
    // the latest position data
    int xpos,ypos,theta;
    unsigned char bumpers[2];
   
    // the client calls this method to make a new proxy
    //   leave access empty to start unconnected
    DescartesProxy(PlayerClient* pc, unsigned short index, 
                  unsigned char access ='c'):
            ClientProxy(pc,PLAYER_DESCARTES_CODE,index,access) {}

    // these methods are the user's interface to this device

    // send a movement command
    //
    // Returns:
    //   0 if everything's ok
    //   -1 otherwise (that's bad)
    int Move(short speed, short heading, short distance );

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    // interface that all proxies SHOULD provide
    void Print();

    // fill in the arguments with the current position
    void GetPos( double* x, double* y, double* th );
};


/*****************************************************************************
 ** begin section GpsProxy
 *****************************************************************************/

/** The {\tt GpsProxy} class is used to control a {\tt gps} device.
    The latest pose data is stored in three class attributes.  */
class GpsProxy : public ClientProxy
{
  public:
    
    /// The latest global pose (in mm, mm, and degrees, respectively).
    int xpos,ypos,heading;
   
    /** Constructor.  Leave the access field empty to start
        unconnected.*/
    GpsProxy(PlayerClient* pc, unsigned short index, 
              unsigned char access='c', unsigned short robot=0) :
            ClientProxy(pc,PLAYER_GPS_CODE,index,access,robot) {}

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current pose information.
    void Print();
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section GripperProxy
 *****************************************************************************/

/* gripper stuff */
#define GRIPopen   1
#define GRIPclose  2
#define GRIPstop   3
#define LIFTup     4
#define LIFTdown   5
#define LIFTstop   6
#define GRIPstore  7
#define GRIPdeploy 8
#define GRIPhalt   15
#define GRIPpress  16
#define LIFTcarry  17

/** The {\tt GripperProxy} class is used to control a {\tt gripper} device.
    The latest gripper data held in a handful of class attributes.
    A single method provides user control.
*/
class GripperProxy : public ClientProxy
{

  public:
    
    /// The latest raw gripper data.
    unsigned char state,beams;

    /** These boolean variables indicate the state of the gripper
     */
    bool outer_break_beam,inner_break_beam,
         paddles_open,paddles_closed,paddles_moving,
         gripper_error,lift_up,lift_down,lift_moving,
         lift_error;

    /** The client calls this method to make a new proxy.  Leave access empty 
         to start unconnected. */
    GripperProxy(PlayerClient* pc, unsigned short index, 
                 unsigned char access='c', unsigned short robot=0) :
            ClientProxy(pc,PLAYER_GRIPPER_CODE,index,access,robot) {}

    // these methods are the user's interface to this device

    /** Send a gripper command.  Look in the Player user manual for details
        on the command and argument.
        Returns 0 if everything's ok, and  -1 otherwise (that's bad).
    */
    int SetGrip(unsigned char cmd, unsigned char arg=0);

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current gripper state.
    void Print();
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


class IDARProxy : public ClientProxy
{
  public:
  
  // the client calls this method to make a new proxy
  //   leave access empty to start unconnected
  IDARProxy(PlayerClient* pc, unsigned short index, 
	    unsigned char access = 'c');
  
  // interface that all proxies must provide
  // reads the receive buffers from player
  //void FillData(player_msghdr_t hdr, const char* buffer);
  
  // interface that all proxies SHOULD provide
  void Print();
  
  // tx parameter is optional; defaults to 0
  int SendMessage( idartx_t* tx );
  
  // get message and transmission details 
  int GetMessage( idarrx_t* rx );  

  // get message and transmission details without flushing the buffer
  int GetMessageNoFlush( idarrx_t* rx );  

  // send and get a message
  int SendGetMessage( idartx_t* tx, idarrx_t* rx );  

  // pretty print a message
  void PrintMessage(idarrx_t* rx); 
};

class IDARTurretProxy : public ClientProxy
{
  public:
  
  // the client calls this method to make a new proxy
  //   leave access empty to start unconnected
  IDARTurretProxy(PlayerClient* pc, unsigned short index, 
	    unsigned char access = 'c', unsigned short robot=0):
  ClientProxy(pc,PLAYER_IDARTURRET_CODE,index,access,robot) {}
  
  // interface that all proxies must provide
  // reads the receive buffers from player
  //void FillData(player_msghdr_t hdr, const char* buffer);
  
  // interface that all proxies SHOULD provide
  void Print();
  
  // tx parameter is optional; defaults to 0
  int SendMessages( player_idarturret_config_t* conf );
  
  // get message and transmission details 
  int GetMessages( player_idarturret_reply_t* reply );  

  // send and get in one operation for efficiency
  int SendGetMessages( player_idarturret_config_t* conf,
		       player_idarturret_reply_t* reply );

  // pretty print a message
  void PrintMessages( player_idarturret_reply_t* reply ); 

  void PrintMessage( idarrx_t* msg );
};


/*****************************************************************************
 ** begin section FiducialProxy
 *****************************************************************************/

/** The {\tt FiducialProxy} class is used to control {\tt fiducial}
    devices.  The latest set of detected beacons is stored in the {\tt
    beacons} array.  */
class FiducialProxy : public ClientProxy
{

  public:
  // the latest laser beacon data

  /** The number of beacons detected 
   */
  unsigned short count;

  /** The latest laser beacon data.  Each beacon has the following
      information: 
      \begin{itemize} 
      \item int16_t id  (-1 for unidentified)
      \item int16_t pose[3] (pose of the beacon)
      \item int16_t upose[3] (uncertainty in the pose of the beacon)
      \end{itemize} 
      Where each pose array is composed of:
      \begin{itemize} 
      \item range (mm)
      \item bearing (degrees)
      \item orient (degrees)
      \end{itemize}  */
  player_fiducial_item_t beacons[PLAYER_FIDUCIAL_MAX_SAMPLES];
   
  /** Constructor.  Leave the access field empty to start
      unconnected. */
  FiducialProxy(PlayerClient* pc, unsigned short index,
                unsigned char access='c', unsigned short robot=0):
    ClientProxy(pc,PLAYER_FIDUCIAL_CODE,index,access,robot) {}
    
  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print out latest beacon data.
  void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section LaserProxy
 *****************************************************************************/

/** The {\tt LaserProxy} class is used to control a {\tt laser}
device.  The latest scan data is held in two arrays: {\tt ranges} and
{\tt intensity}.  The laser scan range, resolution and so on can be
configured using the {\tt Configure()} method.  */
class LaserProxy : public ClientProxy
{

  public:

    /** Scan range for the latest set of data.  Angles are measured in
        units of $0.01^{\circ}$, in the range -9000 ($-90^{\circ}$) to
        +9000 ($+90^{\circ}$).  */
    short min_angle, max_angle;

    /** Scan resolution for the latest set of data.  Resolution is
        measured in units of $0.01^{\circ}$.  Valid values are: 25,
        50, and 100.  */
    unsigned short resolution;

    /// Whether or not reflectance (i.e., intensity) values are being returned.
    bool intensity;

    unsigned short range_count;

    /// The range values (in mm).
    unsigned short ranges[PLAYER_LASER_MAX_SAMPLES];

    // TODO: haven't verified that intensities work yet:
    /// The reflected intensity values (arbitrary units in range 0-7).
    unsigned char intensities[PLAYER_LASER_MAX_SAMPLES];

    unsigned short min_right,min_left;
   
    /** Constructor.  Leave the access field empty to start
        unconnected. */
    LaserProxy(PlayerClient* pc, unsigned short index, 
               unsigned char access='c', unsigned short robot=0):
        ClientProxy(pc,PLAYER_LASER_CODE,index,access,robot) {}

    // these methods are the user's interface to this device

    /** Enable/disable the laser.
      Set {\tt state} to 1 to enable, 0 to disable.
      Note that when laser is disabled the client will still receive laser
      data, but the ranges will always be the last value read from the
      laser before it was disabled.
      Returns 0 on success, -1 if there is a problem.\\
      {\bf Note}: The {\tt sicklms200} driver currently does not implement
      this feature.
     */
    int SetLaserState (const unsigned char state);

    /// Compute the local rectangular coordinate of the i'th beam strike.
    int CartesianCoordinate( int i, int *x, int *y );

    /** Configure the laser scan pattern.  Angles {\tt min\_angle} and
        {\tt max\_angle} are measured in units of $0.1^{\circ}$, in
        the range -9000 ($-90^{\circ}$) to +9000 ($+90^{\circ}$).
        {\tt resolution} is also measured in units of $0.1^{\circ}$;
        valid values are: 25 ($0.25^{\circ}$), 50 ($0.5^{\circ}$) and
        $100 (1^{\circ}$).  Set {\tt intensity} to {\tt true} to
        enable intensity measurements, or {\tt false} to disable.\\
        Returns the 0 on success, or -1 of there is a problem.  */
    int Configure(short min_angle, short max_angle, 
                  unsigned short resolution, bool intensity);

    /** Get the current laser configuration; it is read into the
        relevant class attributes. Returns the 0 on success, or -1
        of there is a problem.  */
    int GetConfigure();

    /// Get the number of range/intensity readings.
    int  RangeCount () { return range_count; }

    /// An alternate way to access the range data.
    uint16_t Ranges (const unsigned int index)
    {
    	if (index < range_count)
    		return ranges[index];
    	else
    		return 0;
    }
    uint16_t MinLeft () { return min_left; }
    uint16_t MinRight () { return min_right; }

    /** Range access operator.  This operator provides an alternate
        way of access the range data.  For example, given an {\tt
        LaserProxy} named {\tt lp}, the following expressions are
        equivalent: \verb+lp.ranges[0]+, \verb+lp.Ranges(0)+, 
        and \verb+lp[0]+.  */
    uint16_t operator [] (unsigned int index)
    {
      return Ranges(index);
    }
    
    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out the latest laser range/intensity data.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

#define MAX_RX_BUF_SIZE 1024

class MoteProxy : public ClientProxy
{
    public: MoteProxy(PlayerClient* pc, unsigned short index, 
		      unsigned char access ='c', unsigned short robot=0);

    public: int Sendto(int src, int dest, char* msg, int len);

    public: int TransmitRaw(char *msg, uint16_t len);

    public: int RecieveRaw(char* msg, uint16_t len, double *rssi);

    public: int Sendto(int to, char* msg, int len);

    public: int SetStrength(uint8_t str);

    public: int GetStrength(void);

    public: int RecieveFrom(int from, char* msg, int len);

    public: inline float GetRSSI(void);

    // interface that all proxies must provide
    protected: void FillData(player_msghdr_t hdr, const char* buffer);
    
    // interface that all proxies SHOULD provide
    protected: void Print();
    
    private: player_mote_data_t *rx_data;

    private: player_mote_data_t *rx_queue;

    private: player_mote_config_t m_config;

    private: char r_flag;

    private: unsigned char msg_q_index;
};


/*****************************************************************************
 ** begin section PositionProxy
 *****************************************************************************/

/** The {\tt PositionProxy} class is used to control a {\tt position} device.
    The latest position data is contained in the attributes {\tt xpos, ypos}, 
    etc.
 */
class PositionProxy : public ClientProxy
{

  public:
  /// Robot pose (according to odometry) in mm, mm, degrees.
  int xpos,ypos,theta;

  /// Robot speeds in mm/sec, mm/sec, degrees/sec.
  int speed, sidespeed, turnrate;

  /// Stall flag: 1 if the robot is stalled and 0 otherwise.
  unsigned char stall;
   
  /** Constructor.
      Leave the access field empty to start unconnected. */
  PositionProxy(PlayerClient* pc, unsigned short index,
                unsigned char access ='c', unsigned short robot = 0) :
    ClientProxy(pc,PLAYER_POSITION_CODE,index,access,robot) {}

  // these methods are the user's interface to this device

  /** Send a motor command for velocity control mode.
      Specify the forward, sideways, and angular speeds in mm/s, mm/s,
      and degrees/sec, respectively.  Returns: 0 if everything's ok, 
      -1 otherwise.
  */
  int SetSpeed(int speed, int sidespeed, int turnrate);

  /** Send a motor command for position control mode.  Specify the
      desired pose of the robot in mm, mm, degrees. Returns: 0 if
      everything's ok, -1 otherwise.  
  */
  int GoTo(int x, int y, int t);


  /** Same as the previous SetSpeed(), but doesn't take the sideways speed 
      (so use this one for non-holonomic robots). */
  int SetSpeed(int speed, int turnrate)
      { return(SetSpeed(speed,0,turnrate));}

  /** Enable/disable the motors.
      Set {\tt state} to 0 to disable or 1 to enable.
      Be VERY careful with this method!  Your robot is likely to run across the
      room with the charger still attached.
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int SetMotorState(unsigned char state);
    
  /** Select velocity control mode.
  
      For the the p2os_position driver, set {\tt mode} to 0 for direct wheel 
      velocity control (default), or 1 for separate translational and 
      rotational control.\\
      For the reb_position driver: 0 is direct velocity control, 1 is for 
      velocity-based heading PD controller (uses DoDesiredHeading()).\\
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int SelectVelocityControl(unsigned char mode);
   
  /** Reset odometry to (0,0,0).
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int ResetOdometry();

  // the following ioctls are currently only supported by reb_position
  //

  /** Select position mode on the reb_position driver.
      Set {\tt mode} for 0 for velocity mode, 1 for position mode.
      Returns: 0 if OK, -1 else
  */
  int SelectPositionMode(unsigned char mode);

  /** Sets the odometry to the pose {\tt (x, y, theta)}.
      Note that {\tt x} and {\tt y} are in mm and {\tt theta} is in degrees.
      Returns: 0 if OK, -1 else
  */
  int SetOdometry(int x, int y, unsigned short t);

  /// Only supported by the reb_position driver.
  int SetSpeedPID(int kp, int ki, int kd);

  /// Only supported by the reb_position driver.
  int SetPositionPID(short kp, short ki, short kd);

  /// Only supported by the reb_position driver.
  int SetPositionSpeedProfile(short spd, short acc);

  /// Only supported by the reb_position driver.
  int DoStraightLine(int mm);

  /// Only supported by the reb_position driver.
  int DoRotation(int deg);

  /// Only supported by the reb_position driver.
  int DoDesiredHeading(int theta, int xspeed, int yawspeed);

  /// Accessor method
  int32_t  Xpos () const { return xpos; }
  
  /// Accessor method
  int32_t  Ypos () const { return ypos; }
  
  /// Accessor method
  int32_t Theta () const { return theta; }
  
  /// Accessor method
  int32_t  Speed () const { return speed; }

  /// Accessor method
  int32_t  TurnRate () const { return turnrate; }
  
  /// Accessor method
  unsigned char Stall () const { return stall; }

  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print current position device state.
  void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PtzProxy
 *****************************************************************************/

/** The {\tt PtzProxy} class is used to control a {\tt ptz} device.
    The state of the camera can be read from the {\tt pan, tilt, zoom}
    attributes and changed using the {\tt SetCam()} method.
 */
class PtzProxy : public ClientProxy
{
  public:
    
    /// Pan, tilt, and field of view values (all degrees).
    short pan, tilt, zoom;

    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    PtzProxy(PlayerClient* pc, unsigned short index, 
             unsigned char access='c', unsigned short robot=0):
            ClientProxy(pc,PLAYER_PTZ_CODE,index,access,robot) {}

    // these methods are the user's interface to this device

    /** Change the camera state.
        Specify the new {\tt pan}, {\tt tilt}, and {\tt zoom} values 
        (all degrees).
        Returns: 0 if everything's ok, -1 otherwise.
    */
    int SetCam(short pan, short tilt, short zoom);

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current ptz state.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section SonarProxy
 *****************************************************************************/

/** The {\tt SonarProxy} class is used to control a {\tt sonar} device.
    The most recent sonar range measuremts can be read from the {\tt range}
    attribute, or using the the {\tt []} operator.
 */
class SonarProxy : public ClientProxy
{

  public:
    /** The number of sonar readings received.
     */
    unsigned short range_count;

    /** The latest sonar scan data.
        Range is measured in mm.
     */
    unsigned short ranges[PLAYER_SONAR_MAX_SAMPLES];

    /** Positions of sonars.  Contains:
        \begin{itemize}
        \item uint16_t pose_count (number of valid poses)
        \item int16_t poses[PLAYER_SONAR_MAX_SAMPLES][3] (the poses)
        \end{itemize}
        Where each pose in the array is: (x,y,theta) (mm,mm,degrees).
     */
    player_sonar_geom_t sonar_pose;
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    SonarProxy(PlayerClient* pc, unsigned short index, 
               unsigned char access = 'c',unsigned short robot=0) :
            ClientProxy(pc,PLAYER_SONAR_CODE,index,access,robot)
    { bzero(&sonar_pose,sizeof(sonar_pose)); }

    // these methods are the user's interface to this device
    
    /** Enable/disable the sonars.
        Set {\tt state} to 1 to enable, 0 to disable.
        Note that when sonars are disabled the client will still receive sonar
        data, but the ranges will always be the last value read from the sonars
        before they were disabled.\\
        Returns 0 on success, -1 if there is a problem.
     */
    int SetSonarState(unsigned char state);

    /// Request the sonar geometry.
    int GetSonarGeom();

    /** Range access operator.
        This operator provides an alternate way of access the range data.
        For example, given a {\tt SonarProxy} named {\tt sp}, the following
        expressions are equivalent: \verb+sp.ranges[0]+ and \verb+sp[0]+.
     */
    unsigned short operator [](unsigned int index) 
    { 
      if(index < sizeof(ranges))
        return(ranges[index]);
      else 
        return(0);
    }

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current sonar range data.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section SpeechProxy
 *****************************************************************************/

/** The {\tt SpeechProxy} class is used to control a
    {\tt speech} device.  Use the {\tt say} method to send things to say.
*/
class SpeechProxy : public ClientProxy
{

  public:
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    SpeechProxy(PlayerClient* pc, unsigned short index, 
                unsigned char access='c',unsigned short robot=0):
            ClientProxy(pc,PLAYER_SPEECH_CODE,index,access,robot) {}

    // these methods are the user's interface to this device

    /** Send a phrase to say.
        The phrase is an ASCII string.
        Returns the 0 on success, or -1 of there is a problem.
    */
    int Say(char* str);
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section TruthProxy
 *****************************************************************************/

/** The {\tt TruthProxy} gets and sets the {\em true} pose of a truth
    device [worldfile tag: truth()]. This may be different from the
    pose returned by a device such as GPS or Position. If you want to
    log what happened in an experiment, this is the device to
    use. 

    Setting the position of a truth device moves its parent, so you
    can put a truth device on robot and teleport it around the place. 
 */
class TruthProxy : public ClientProxy
{
  
  public:

  /** These vars store the current device pose (x,y,a) as
      (m,m,radians). The values are updated at regular intervals as
      data arrives. You can read these values directly but setting
      them does NOT change the device's pose!. Use {\tt
      TruthProxy::SetPose()} for that.  */
  double x, y, a; 

  /** Constructor.
      Leave the access field empty to start unconnected.
  */
  TruthProxy(PlayerClient* pc, unsigned short index, 
             unsigned char access = 'c',unsigned short robot=0) :
    ClientProxy(pc,PLAYER_TRUTH_CODE,index,access,robot=0) {};

    
  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print out current pose info in a format suitable for data logging.
  void Print();

  /** Query Player about the current pose - requests the pose from the
      server, then fills in values for the arguments
      (m,m,radians). Usually you'll just read the {\tt x,y,a}
      attributes but this function allows you to get pose direct from
      the server if you need too. Returns 0 on success, -1 if there is
      a problem.  
  */
  int GetPose( double *px, double *py, double *pa );

  /** Request a change in pose (m,m,radians). Returns 0 on success, -1
      if there is a problem.  
  */
  int SetPose( double px, double py, double pa );
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section BlobfinderProxy
 *****************************************************************************/

class Blob
{
  public:
    unsigned int color;
    unsigned int area;
    unsigned short x;
    unsigned short y;
    unsigned short left;
    unsigned short right;
    unsigned short top;
    unsigned short bottom;
    unsigned short range;
};


/** The {\tt BlobfinderProxy} class is used to control a {\tt blobfinder} 
    device.  It contains no methods.  The latest color blob data is stored in
    {\tt blobs}, a dynamically allocated 2-D array, indexed by color
    channel.
*/
class BlobfinderProxy : public ClientProxy
{

  public:
    
    /// Dimensions of the camera image, in pixels
    unsigned short width, height;

    /** Array containing the number of blobs detected on each channel 
     */ 
    char num_blobs[PLAYER_BLOBFINDER_MAX_CHANNELS];

    /** Array containing arrays of the latest blob data.
        Each blob contains the following information:
        \begin{itemize}
        \item {\tt unsigned int color} (in packed RGB);
        \item {\tt unsigned int area} (blob area, in square pixels)
        \item {\tt unsigned short x, y} (blob center, in pixels);
        \item {\tt unsigned short left, right, top, bottom} (blob bounding box,
        in pixels)
        \end{itemize}
        For example, to access the area of the $0^{th}$ blob on channel 2, you
        would refer to: {\tt blobs[2][0].area}.
     */
    Blob* blobs[PLAYER_BLOBFINDER_MAX_CHANNELS];
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    BlobfinderProxy(PlayerClient* pc, unsigned short index, 
                unsigned char access='c',unsigned short robot=0);
    ~BlobfinderProxy();

    // these methods are the user's interface to this device

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current blob information.
    void Print();
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


// these define default coefficients for our 
// range and standard deviation estimates
#define IRPROXY_DEFAULT_DIST_M_VALUE -0.661685227
#define IRPROXY_DEFAULT_DIST_B_VALUE  10.477102515

#define IRPROXY_DEFAULT_STD_M_VALUE  1.913005560938
#define IRPROXY_DEFAULT_STD_B_VALUE -7.728130591833

#define IRPROXY_M_PARAM 0
#define IRPROXY_B_PARAM 1

//this is the effective range of the sensor in mm
#define IRPROXY_MAX_RANGE 700

/*****************************************************************************
 ** begin section IRProxy
 *****************************************************************************/

/** The {\tt IRProxy} class is used to control an {\tt ir} device.   Right
    now, it is particular to the {\tt reb_ir} driver.
 */
class IRProxy : public ClientProxy
{
public:

  /// Latest range readings
  unsigned short ranges[PLAYER_IR_MAX_SAMPLES];
  
  /// Latest voltage readings
  unsigned short voltages[PLAYER_IR_MAX_SAMPLES];

  /// Standard deviations
  double stddev[PLAYER_IR_MAX_SAMPLES];

  /// Distance regression params
  double params[PLAYER_IR_MAX_SAMPLES][2]; 

  /// Standard deviation regression params
  double sparams[PLAYER_IR_MAX_SAMPLES][2]; 

  /** Poses of the IRs.  Contains:
      \begin{itemize}
      \item short poses[PLAYER_IR_MAX_SAMPLES][3];
      \end{itemize}
      Where each pose element contains: (x,y,theta) in (mm,mm,degrees). */
  player_ir_pose_t ir_pose;

    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  IRProxy(PlayerClient *pc, unsigned short index,
          unsigned char access = 'c');

  /// Enable/disable the IRs.
  int SetIRState(unsigned char state);

  /// Request the poses of the IRs.
  int GetIRPose();

  /// Set range parameters.
  void SetRangeParams(int which, double m, double );

  /// Set standard deviation parameters.
  void SetStdDevParams(int which, double m, double b);

  /// Calculate standard deviations.
  double CalcStdDev(int w, unsigned short range);

    /** Range access operator.
        This operator provides an alternate way of access the range data.
        For example, given a {\tt IRProxy} named {\tt ip}, the following
        expressions are equivalent: \verb+ip.ranges[0]+ and \verb+ip[0]+.
     */
  unsigned short operator [](unsigned int index) 
  {
    if (index < PLAYER_IR_MAX_SAMPLES) {
      return ranges[index];
    } 

    return 0;
  }

  // required methods
  void FillData(player_msghdr_t hdr, const char *buffer);

  /// Print out current IR data.
  void Print();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section WiFiProxy
 *****************************************************************************/

/** The {\tt WiFiProxy} class controls a {\tt wifi} device.
 */
class WiFiProxy: public ClientProxy
{
public:


    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  WiFiProxy(PlayerClient *pc, unsigned short index, 
	       unsigned char access = 'c',unsigned short robot=0) : 
    ClientProxy(pc, PLAYER_WIFI_CODE, index, access,robot), link_count(0) {}


  int GetLinkQuality(char * ip = NULL);
  int GetLevel(char * ip = NULL);
  int GetLeveldBm(char * ip = NULL) { return GetLevel(ip) - 0x100; }
  int GetNoise(char * ip = NULL);
  int GetNoisedBm(char * ip = NULL) { return GetNoise(ip) - 0x100; }

  int GetBitrate();

  char * GetMAC(char *buf, int len);
  void FillData(player_msghdr_t hdr, const char *buffer);

  /// Print out current data.
  void Print();

protected:
  int GetLinkIndex(char *ip);

  /// The current wifi data.
  int link_count;
  player_wifi_link_t links[PLAYER_WIFI_MAX_LINKS];
  uint32_t throughput;
  uint8_t op_mode;
  int32_t bitrate;
  
  char access_point[32];

};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PowerProxy
 *****************************************************************************/

/** The {\tt PowerProxy} class controls a {\tt power} device.
 */
class PowerProxy : public ClientProxy 
{

  public:
    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    PowerProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c',unsigned short robot=0)
            : ClientProxy(pc,PLAYER_POWER_CODE,index,access,robot) {}

    /// Returns the current charge.
    uint16_t Charge () const { return charge; }

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print the current data.
    void Print ();

  private:
    // Remaining power in centivolts
    uint16_t charge;
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section AudioProxy
 *****************************************************************************/

/** The {\tt AudioProxy} class controls an {\tt audio} device.
 */
class AudioProxy : public ClientProxy 
{

  public:
    /** Hz, db ? */
    uint16_t frequency0, amplitude0;
    /** Hz, db ? */
    uint16_t frequency1, amplitude1;
    /** Hz, db ? */
    uint16_t frequency2, amplitude2;
    /** Hz, db ? */
    uint16_t frequency3, amplitude3;
    /** Hz, db ? */
    uint16_t frequency4, amplitude4;

    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    AudioProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c')
            : ClientProxy(pc,PLAYER_AUDIO_CODE,index,access) {}

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Play a fixed-frequency tone
    int PlayTone(unsigned short freq, unsigned short amp, unsigned short dur);

    /// Print the current data.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section BumperProxy
 *****************************************************************************/

/** The {\tt BumperProxy} class is used to read from a {\tt bumper} device.
 */
class BumperProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    BumperProxy (PlayerClient* pc, unsigned short index,
                   unsigned char access = 'c',unsigned short robot=0)
            : ClientProxy(pc,PLAYER_BUMPER_CODE,index,access,robot) 
      {}

    ~BumperProxy()
      {}

    // these methods are the user's interface to this device

    /** Returns 1 if the specified bumper has been bumped, 0 otherwise.
      */
    bool Bumped (const unsigned int i);

    /** Returns 1 if any bumper has been bumped, 0 otherwise.
      */
    bool BumpedAny ();

    /** Requests the geometries of the bumpers.
        Returns -1 if anything went wrong, 0 if OK
     */ 
    int GetBumperGeom( player_bumper_geom_t* bumper_defs );

    /// Returns the number of bumper readings.
    uint8_t BumperCount () const { return bumper_count; }

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current bumper state.
    void Print ();

private:
    /** array representing bumped state.
     */
    uint8_t bumper_count;
    uint8_t bumpers[PLAYER_BUMPER_MAX_SAMPLES];
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section DIOProxy
 *****************************************************************************/

/** The {\tt DIOProxy} class is used to read from a {\tt dio} (digital I/O)
    device.
 */
class DIOProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    DIOProxy (PlayerClient* pc, unsigned short index,
                   unsigned char access = 'c',unsigned short robot=0)
            : ClientProxy(pc,PLAYER_DIO_CODE,index,access,robot) 
      {}

    ~DIOProxy()
      {}

    /// The number of valid digital inputs.
    char count;

    /// A bitfield of the current digital inputs.
    unsigned int digin;
    
    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current digital input state.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section WaveformProxy
 *****************************************************************************/

/** The {\tt WaveformProxy} class is used to read raw digital
 waveforms from a device.  */
class WaveformProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  WaveformProxy (PlayerClient* pc, unsigned short index,
		 unsigned char access = 'c',unsigned short robot=0)
    : ClientProxy(pc,PLAYER_WAVEFORM_CODE,index,access,robot) 
    {
      this->ConfigureDSP(); // use latest settings	
    }
  
  ~WaveformProxy();
  
    /// sample rate in bits per second
    unsigned int bitrate;

    /// sample depth in bits
    unsigned short depth;

    //// the number of samples in the most recent packet
    unsigned int last_samples;

    /// the data is buffered here for playback
    unsigned char buffer[PLAYER_WAVEFORM_DATA_MAX];
  
    /// dsp file descriptor
    int fd; 
  
    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current status
    void Print ();

    // set up the DSP to the current bitrate and depth
    int ConfigureDSP() ;

    // open the sound device 
    void OpenDSPforWrite();

    // Play the waveform through the DSP
    void Play();

};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section MComProxy
 *****************************************************************************/

/*  MComProxy class by Matt Brewer <mbrewer@andrew.cmu.edu> at 
 *  UMass Amherst 2002 (updated for player 1.3 by reed)
 */                      

// this is from the player server (server/drivers/mcom/ in the source tree)
//#include "player_mcom_types.h"

/** The {\tt MComProxy} class is used to exchange data with other clients
    connected with the same server, through a set of named "channels". */
class MComProxy : public ClientProxy 
{

public:
    /** These members contain the results of the last command.
        Note: It's better to use the LastData() method. */   
    player_mcom_data_t data;
    int type;
    char channel[MCOM_CHANNEL_LEN];

public:
    MComProxy(PlayerClient* pc, unsigned short index, 
              unsigned char access = 'c',
              unsigned short robot=0) : 
            ClientProxy(pc,PLAYER_MCOM_CODE,index,access,robot){}

    /** Read and remove the most recent buffer in 'channel' with type 'type'.
        The result can be read with LastData(). */
    int Pop(int type, char channel[MCOM_CHANNEL_LEN]);

    /** Read the most recent buffer in 'channel' with type 'type'.
        The result can be read with LastData() after the next call to
        PlayerClient::Read().  */
    int Read(int type, char channel[MCOM_CHANNEL_LEN]);

    /* Read the most recent buffer in 'channel' with type 'type'.
       The result is placed in 'result'
    int Read(int type, char channel[MCOM_CHANNEL_LEN], char result[MCOM_DATA_LEN]);
     */

    /** Push a message 'dat' into channel 'channel' with message type 'type'. */
    int Push(int type, char channel[MCOM_CHANNEL_LEN], char dat[MCOM_DATA_LEN]);

    /** Clear all messages of type 'type' on channel 'channel' */
    int Clear(int type, char channel[MCOM_CHANNEL_LEN]);

    /** Get the results of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    char* LastData() { return data.data; }
    /** Get the results of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    int LastMsgType() { return type; }
    /** Get the results of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    char* LastChannel() { return channel; }

    void FillData(player_msghdr_t hdr, const char* buffer);
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


#endif
