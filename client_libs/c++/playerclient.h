/*
 *  Player - One Hell of a Robot Server
 *  Copyright (C) 2000-2003
 *     Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
 *                      
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
/*
 *  Player - One Hell of a Robot Server
 *  Copyright (C) 2003
 *     Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
 *                      
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * $Id$
 *
 * the C++ client
 */

#ifndef PLAYERCLIENT_H
#define PLAYERCLIENT_H

#include <player.h>       /* from the server; gives message types */
#include <playercclient.h>  /* pure C networking building blocks */

#if HAVE_STRINGS_H
  #include <strings.h>
#endif

#include <sys/time.h>
struct pollfd;
#include <string.h>

// Convert radians to degrees
//
#ifndef RTOD
#define RTOD(r) ((r) * 180 / M_PI)
#endif

// Convert degrees to radians
//
#ifndef DTOR
#define DTOR(d) ((d) * M_PI / 180)
#endif

// Normalize angle to domain -pi, pi
//
#ifndef NORMALIZE
#define NORMALIZE(z) atan2(sin(z), cos(z))
#endif

// forward declaration for friending
class PlayerClient;

/*****************************************************************************
 ** begin section ClientProxy
 *****************************************************************************/

/**
Base class for all proxy devices. Access to a device is provided by a
device-specific proxy class.  These classes all inherit from the {\tt
ClientProxy} class which defines an interface for device proxies.  As such,
a few methods are common to all devices and we explain them here.
*/
class ClientProxy
{
  friend class PlayerClient; // ANSI C++ syntax?

  public:         
     /** The controlling client object.
      */
    PlayerClient* client;

    /** Have we yet received any data from this device?
     */
    bool valid;

    // the last message header and body will be copied here by StoreData(), so
    // that it's available for later use.
    unsigned char last_data[PLAYER_MAX_MESSAGE_SIZE];
    player_msghdr_t last_header;

    unsigned char access;   // 'r', 'w', or 'a' (others?)
    //unsigned short robot;  // to which robot this proxy pertains
    //unsigned short device; // the name by which we identify this kind of device
    //unsigned short index;  // which device we mean
    player_device_id_t m_device_id;

    /** The name of the driver used to implement this device in the server.
     */
    char driver_name[PLAYER_MAX_DEVICE_STRING_LEN]; // driver in use

    /** Time at which this data was generated by the device. 
     */
    struct timeval timestamp;  

    /** Time at which this data was sent by the server. 
      */
    struct timeval senttime;   

    /** Time at which this data was received by the client. 
     */
    struct timeval receivedtime;

    /** This constructor will try to get access to the device,
        unless {\tt req_device} is 0 or {\tt req_access} is 'c'.
        The pointer {\tt pc} must refer to an already connected 
        {\tt PlayerClient} proxy.  The {\tt index} indicates which one of the
        devices to use (usually 0).  Note that a request executed by this
        the constructor can fail, but the constructor cannot indicate the
        failure.  Thus, if you request a particular access mode, you should 
        verify that the current access is identical to your requested access 
        using {\tt GetAccess()}.  In any case, you can use 
        {\tt ChangeAccess()} later to change your access mode for the device.
    */
    ClientProxy(PlayerClient* pc, 
		unsigned short req_device,
		unsigned short req_index,
		unsigned char req_access = 'c');

    // destructor will try to close access to the device
    virtual ~ClientProxy();

    /**  Returns the current access mode for the device.
     */
    unsigned char GetAccess() { return(access); };  

    /** Request different access for the device.  If {\tt grant_access} is
        non-NULL, then it is filled in with the granted access.  Returns 0
        on success, -1 otherwise. */
    int ChangeAccess(unsigned char req_access, 
                     unsigned char* grant_access=NULL );

    /** Convenience method for requesting 'c' access.
     */
    int Close() { return(ChangeAccess('c')); }

    /** All proxies must provide this method.  It is used internally to parse
        new data when it is received. */
    virtual void FillData(player_msghdr_t hdr, const char* buffer);

    /** This method is used internally to keep a copy of the last message from
        the device **/
    void StoreData(player_msghdr_t hdr, const char* buffer);
    
    /** All proxies SHOULD provide this method, which should print out, in a
        human-readable form, the device's current state. */
    virtual void Print();
};

// keep a linked list of proxies that we've got open
class ClientProxyNode
{
  public:
    ClientProxy* proxy;
    ClientProxyNode* next;
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section PlayerClient
 *****************************************************************************/

/** One {\tt PlayerClient} object is used to control each connection to
    a Player server.  Contained within this object are methods for changing the
    connection parameters and obtaining access to devices, which we explain 
    next.
 */
class PlayerClient
{
  private:
    // special flag to indicate that we are being destroyed
    bool destroyed;

    // list of proxies associated with us
    ClientProxyNode* proxies;
    int num_proxies;

    int reserved;
    
    // get the pointer to the proxy for the given device and index
    //
    // returns NULL if we can't find it.
    //
    ClientProxy* GetProxy(unsigned short device, 
                                        unsigned short index);
    ClientProxy* GetProxy(player_device_id_t id);

  public:
    //  Struct containing information about the  connection to Player
    player_connection_t conn;

    // are we connected? 
    bool connected;

    //void SetReserved(int res) { reserved = res; }
    //int GetReserved() { return(reserved); }

    /** Flag set if data has just been read into this client.  If you
        use it, you must set it to false yourself after examining the data.
        */ 
    bool fresh; 

    /** The host of the Player server to which we are connected.
     */
    char hostname[256]; 

    /** The port of the Player server to which we are connected.
        */ 
    int port;
    
    // store the IP of the host, too - more efficient for
    // matching, etc, then the string
    struct in_addr hostaddr;

    /** The latest time received from the server.
       */
    struct timeval timestamp;

    // constructors
    
    /** Make a client and connect it as indicated.
        If {\tt hostname} is omitted (or NULL) then the client will {\em not}
        be connected.  In that cast, call {\tt Connect()} yourself later.
     */
    PlayerClient(const char* hostname=NULL,
                 const int port=PLAYER_PORTNUM,
                 const int protocol=PLAYER_TRANSPORT_TCP);

    /** Make a client and connect it as indicated, using a binary IP instead 
        of a hostname
      */
    PlayerClient(const struct in_addr* hostaddr,
                 const int port,
                 const int protocol=PLAYER_TRANSPORT_TCP);

    // destructor
    ~PlayerClient();

    /** Connect to the indicated host and port.\\
        Returns 0 on success; -1 on error.
     */
    int Connect(const char* hostname="localhost", int port=PLAYER_PORTNUM);

    /** Connect to the indicated host and port, using a binary IP.\\
        Returns 0 on success; -1 on error.
     */
    int Connect(const struct in_addr* addr, int port);

    /** Connect to a robot, based on its name, by using the Player robot name 
        service (RNS) on the indicated host and port.  Returns 0 on success; 
        -1 on error.
     */
    int ConnectRNS(const char* robotname, const char* hostname="localhost",
                   int port=PLAYER_PORTNUM);

    /** Disconnect from server.\\
        Returns 0 on success; -1 on error.
      */
    int Disconnect();

    /** Check if we are connected.
      */
    bool Connected() { return((conn.sock >= 0) ? true : false); }

    /**
    This method will read one round of data; that is, it will read until a 
    SYNC packet is received from the server.  Depending on which data delivery
    mode is in use, new data may or may not be received for each open device.
    The data that is received for each device device will be processed by the
    appropriate device proxy and stored there for access by your program.
    If no errors occurred 0 is returned.  Otherwise, -1 is returned and
    diagnostic information is printed to {\tt stderr} (you should probably
    close the connection!).
    */
    int Read();
    
    /** Write a command to the server.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 on success, -1 otherwise. */
    int Write(player_device_id_t device_id,
              const char* command, size_t commandlen);

    /** Send a request to the server.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 on success, -1 otherwise. */
    int Request(player_device_id_t device_id,
                const char* payload,
                size_t payloadlen,
                player_msghdr_t* replyhdr,
                char* reply, size_t replylen);

    /** Another form of Request(), this one can be used if the caller is not
        interested in the reply.  This method is {\bf not} intended for
        direct use.  Rather, device proxies should implement higher-level 
        methods atop this one. Returns 0 if an ACK is received, -1 
        otherwise. */
    int Request(player_device_id_t device_id,
                const char* payload,
                size_t payloadlen);
    
    /**
      Request access to a device; meant mostly for use by client-side device 
      proxy constructors.
      {\tt req_access} is requested access.
      {\tt grant_access}, if non-NULL, will be filled with the granted access.
      Returns 0 if everything went OK or -1 if something went wrong.
    */
    int RequestDeviceAccess(player_device_id_t device_id,
                            unsigned char req_access,
                            unsigned char* grant_access,
                            char* driver_name = NULL,
                            int driver_name_len = 0);

    // Player device configurations

    /**
      You can change the rate at which your client receives data from the 
      server with this method.  The value of {\tt freq} is interpreted as Hz; 
      this will be the new rate at which your client receives data (when in 
      continuous mode).  On error, -1 is returned; otherwise 0.
     */
    int SetFrequency(unsigned short freq);

    /** You can toggle the mode in which the server sends data to your 
        client with this method.  The {\tt mode} should be one of:
        \begin{itemize}
        \item {\tt PLAYER_DATAMODE_PUSH_ALL} (all data at fixed frequency)
        \item {\tt PLAYER_DATAMODE_PULL_ALL} (all data on demand)
        \item {\tt PLAYER_DATAMODE_PUSH_NEW} (only new new data at fixed freq)
        \item {\tt PLAYER_DATAMODE_PULL_NEW} (only new data on demand)
        \end{itemize}
        On error, -1 is returned; otherwise 0.
      */
    int SetDataMode(unsigned char mode);

    /** When in a {\tt PULL} data delivery mode, you can request a single 
        round of data using this method.  On error -1 is returned; otherwise 0.
      */
    int RequestData();

    /** Attempt to authenticate your client using the provided key.  If 
        authentication fails, the server will close your connection.
      */
    int Authenticate(char* key);

    /** Documentation on LookupPort goes here
     */
    int LookupPort(const char* name);
    
    // proxy list management methods

    // add a proxy to the list
    void AddProxy(ClientProxy* proxy);
    // remove a proxy from the list
    void RemoveProxy(ClientProxy* proxy);
};


/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PlayerMultiClient
 *****************************************************************************/

// forward declaration to avoid including <sys/poll.h>, which may not be
// available when people are building clients against this lib
struct pollfd;

/**
  The PlayerMultiClient makes it easy to control multiple Player connections 
  within one thread.   You can connect to any number of Player servers and
  read from all of them with a single {\tt Read()}.
  */
class PlayerMultiClient
{
  private:
    // dynamically managed array of our clients
    PlayerClient** clients;
    //int num_clients;
    int size_clients;

    // dynamically managed array of structs that we'll give to poll(2)
    struct pollfd* ufds;
    int size_ufds;
    int num_ufds;

  public:
    /** Uninteresting constructor. 
    */
    PlayerMultiClient();
    
    // destructor
    ~PlayerMultiClient();

    /** How many clients are currently being managed? 
     */
    int GetNumClients(void) { return num_ufds; };

    /** Return a pointer to the client associated with the given host and port,
        or NULL if none is connected to that address. */
    PlayerClient* GetClient( char* host, int port );

    /** Return a pointer to the client associated with the given binary host 
        and port, or NULL if none is connected to that address. */
    PlayerClient* GetClient( struct in_addr* addr, int port );
    
    /** After creating and connecting a PlayerClient object, you should use 
        this method to hand it over to the PlayerMultiClient for management.
        */
    void AddClient(PlayerClient* client);
    
    /** Remove a client from PlayerMultiClient management.
     */
    void RemoveClient(PlayerClient* client);

    /** Read on one of the client connections.  This method will return after 
        reading from the server with first available data.  It will {\bf
        not} read data from all servers.  You can use the {\tt fresh} flag
        in each client object to determine who got new data.  You should
        then set that flag to false.  Returns 0 if everything went OK,
        -1 if something went wrong. */
    int Read();

    /** Same as Read(), but reads everything off the socket so we end
        up with the freshest data, subject to N maximum reads. */
    int ReadLatest( int max_reads );
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section AIOProxy
 *****************************************************************************/

/** The {\tt AIOProxy} class is used to read from a {\tt aio} (analog I/O)
    device.
 */
class AIOProxy : public ClientProxy
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    AIOProxy (PlayerClient* pc, unsigned short index,
                   unsigned char access = 'c')
            : ClientProxy(pc,PLAYER_AIO_CODE,index,access)
      {}

    ~AIOProxy()
      {}

    /// The number of valid digital inputs.
    char count;

    /// A bitfield of the current digital inputs.
    int anin[PLAYER_AIO_MAX_SAMPLES];

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current digital input state.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section CommsProxy
 *****************************************************************************/

/** The {\tt CommsProxy} class controls a {\tt comms} device.
Data may be written one message at a time using the {\tt Write} method.  

Incoming data are stored in a set of parallel lists:
\begin{itemize}
\item {\tt uint8_t** msg} : list of pointers to message data
\item {\tt size_t* msg_len} : list of message lengths
\item {\tt struct timeval* msg_ts} : list of message timestamps
\end{itemize}
The current number of valid messages is stored in {\tt msg_num}, and so each 
list should be considered to be of length {\tt msg_num}.

To delete a message from the lists, use {\tt Delete()}.
*/
class CommsProxy : public ClientProxy
{
  /** Proxy constructor.  Leave the access field empty to start
      unconnected.  */
  public: CommsProxy(PlayerClient* pc, unsigned short index, 
                     unsigned char access ='c');

  public: ~CommsProxy();

  /** Write a message to the outgoing queue.
      Returns the number of bytes written, or -1 on error.
  */
  public: int Write(void *msg, int len);

  // interface that all proxies must provide
  protected: void FillData(player_msghdr_t hdr, const char* buffer);
  
  /// Delete the given message.  Returns 0 on success and -1 on error.
  public: int Delete(int index);
    
  /// Print out current message.
  public: void Print();

  /// List of received messages.
  public: uint8_t** msg;
  
  /// List of lengths of the received messages.
  public: size_t* msg_len;
  
  /// List of timestamps of the received messages.
  public: struct timeval* msg_ts;

  /// Number of received messages 
  public: size_t msg_num;

  // Current allocated length of msg and msg_len
  private: size_t listlen;
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


class DescartesProxy : public ClientProxy
{

  public:
    // the latest position data
    int xpos,ypos,theta;
    unsigned char bumpers[2];
   
    // the client calls this method to make a new proxy
    //   leave access empty to start unconnected
    DescartesProxy(PlayerClient* pc, unsigned short index, 
                  unsigned char access ='c') :
            ClientProxy(pc,PLAYER_DESCARTES_CODE,index,access) {}

    // these methods are the user's interface to this device

    // send a movement command
    //
    // Returns:
    //   0 if everything's ok
    //   -1 otherwise (that's bad)
    int Move(short speed, short heading, short distance );

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    // interface that all proxies SHOULD provide
    void Print();

    // fill in the arguments with the current position
    void GetPos( double* x, double* y, double* th );
};


/*****************************************************************************
 ** begin section GpsProxy
 *****************************************************************************/

/** The {\tt GpsProxy} class is used to control a {\tt gps} device.
    The latest pose data is stored in three class attributes.  */
class GpsProxy : public ClientProxy
{
  public:
    
    /// Latitude and longitude, in degrees.
    double latitude;
    double longitude;

    /// Altitude, in meters.
    double altitude;

    /// Number of satellites in view.
    int satellites;

    /// Fix quality
    int quality;
    
    /// Horizontal dilution of position (HDOP)
    double hdop;

    /// Time, since the epoch
    struct timeval time;
   
    /** Constructor.  Leave the access field empty to start
        unconnected.*/
    GpsProxy(PlayerClient* pc, unsigned short index, 
              unsigned char access='c') :
            ClientProxy(pc,PLAYER_GPS_CODE,index,access) {}

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current pose information.
    void Print();
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section GripperProxy
 *****************************************************************************/

/* gripper stuff */
#define GRIPopen   1
#define GRIPclose  2
#define GRIPstop   3
#define LIFTup     4
#define LIFTdown   5
#define LIFTstop   6
#define GRIPstore  7
#define GRIPdeploy 8
#define GRIPhalt   15
#define GRIPpress  16
#define LIFTcarry  17

/** The {\tt GripperProxy} class is used to control a {\tt gripper} device.
    The latest gripper data held in a handful of class attributes.
    A single method provides user control.
*/
class GripperProxy : public ClientProxy
{

  public:
    
    /// The latest raw gripper data.
    unsigned char state,beams;

    /** These boolean variables indicate the state of the gripper
     */
    bool outer_break_beam,inner_break_beam,
         paddles_open,paddles_closed,paddles_moving,
         gripper_error,lift_up,lift_down,lift_moving,
         lift_error;

    /** The client calls this method to make a new proxy.  Leave access empty 
         to start unconnected. */
    GripperProxy(PlayerClient* pc, unsigned short index, 
                 unsigned char access='c') :
            ClientProxy(pc,PLAYER_GRIPPER_CODE,index,access) {}

    // these methods are the user's interface to this device

    /** Send a gripper command.  Look in the Player user manual for details
        on the command and argument.
        Returns 0 if everything's ok, and  -1 otherwise (that's bad).
    */
    int SetGrip(unsigned char cmd, unsigned char arg=0);

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current gripper state.
    void Print();
};


/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section SoundProxy
 *****************************************************************************/

/** The {\tt SoundProxy} class is used to control a {\tt sound} device,
    which allows you to play pre-recorded sound files on a robot.
*/
class SoundProxy : public ClientProxy
{

  public:
    
    /** The client calls this method to make a new proxy.  Leave access empty 
         to start unconnected. */
    SoundProxy(PlayerClient* pc, unsigned short index, 
                 unsigned char access='c') :
            ClientProxy(pc,PLAYER_SOUND_CODE,index,access) {}

    // these methods are the user's interface to this device
    
    /** Play the sound indicated by the index.  Returns 0 on success, -1 on
        error.
     */
    int Play(int index);

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer) {};
    
    /// Does nothing.
    void Print() {};
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


class IDARProxy : public ClientProxy
{
  public:
  
  // the client calls this method to make a new proxy
  //   leave access empty to start unconnected
  IDARProxy(PlayerClient* pc, unsigned short index, 
	    unsigned char access = 'c') :
   ClientProxy(pc,PLAYER_IDAR_CODE,index,access) {}
 
  // interface that all proxies must provide
  // reads the receive buffers from player
  //void FillData(player_msghdr_t hdr, const char* buffer);
  
  // interface that all proxies SHOULD provide
  void Print();
  
  // tx parameter is optional; defaults to 0
  int SendMessage( idartx_t* tx );
  
  // get message and transmission details 
  int GetMessage( idarrx_t* rx );  

  // get message and transmission details without flushing the buffer
  int GetMessageNoFlush( idarrx_t* rx );  

  // send and get a message
  int SendGetMessage( idartx_t* tx, idarrx_t* rx );  

  // pretty print a message
  void PrintMessage(idarrx_t* rx); 
};

class IDARTurretProxy : public ClientProxy
{
  public:
  
  // the client calls this method to make a new proxy
  //   leave access empty to start unconnected
  IDARTurretProxy(PlayerClient* pc, unsigned short index, 
	    unsigned char access = 'c') :
  ClientProxy(pc,PLAYER_IDARTURRET_CODE,index,access) {}
  
  // interface that all proxies must provide
  // reads the receive buffers from player
  //void FillData(player_msghdr_t hdr, const char* buffer);
  
  // interface that all proxies SHOULD provide
  void Print();
  
  // tx parameter is optional; defaults to 0
  int SendMessages( player_idarturret_config_t* conf );
  
  // get message and transmission details 
  int GetMessages( player_idarturret_reply_t* reply );  

  // send and get in one operation for efficiency
  int SendGetMessages( player_idarturret_config_t* conf,
		       player_idarturret_reply_t* reply );

  // pretty print a message
  void PrintMessages( player_idarturret_reply_t* reply ); 

  void PrintMessage( idarrx_t* msg );
};


/*****************************************************************************
 ** begin section FiducialProxy
 *****************************************************************************/

class FiducialItem
{
  public:
    int id;
    double pose[3];
    double upose[3];
};

/** The {\tt FiducialProxy} class is used to control {\tt fiducial}
    devices.  The latest set of detected beacons is stored in the {\tt
    beacons} array.  */

class FiducialProxy : public ClientProxy
{

  public:
  // the latest laser beacon data

  /** The number of beacons detected 
   */
  unsigned short count;

  /** The pose of the sensor [x,y,theta] in [m,m,rad]
   */
  double pose[3];

  /** The size of the sensor [x,y] in [m,m]
   */
  double size[2];

  /** The size of the most recently detected fiducial
  */
  double fiducial_size[2];

  /** the minimum range of the sensor in meters (partially defines the FOV)
   */
  double min_range;
  
  /** the maximum range of the sensor in meters (partially defines the FOV)
   */
  double max_range;

  /** the receptive angle of the sensor in degrees (partially defines the FOV)
   */
  double view_angle;

  /** The latest laser beacon data.  Each beacon has the following
      information: 
      \begin{itemize} 
      \item int id  (-1 for unidentified)
      \item double pose[3] (pose of the beacon)
      \item double upose[3] (uncertainty in the pose of the beacon)
      \end{itemize} 
      Where each pose array is composed of:
      \begin{itemize} 
      \item range (m)
      \item bearing (radians)
      \item orient (radians)
      \end{itemize}  */
  FiducialItem beacons[PLAYER_FIDUCIAL_MAX_SAMPLES];
   
  /** Constructor.  Leave the access field empty to start
      unconnected. */
  FiducialProxy(PlayerClient* pc, unsigned short index,
                unsigned char access='c') :
    ClientProxy(pc,PLAYER_FIDUCIAL_CODE,index,access) {}
    
  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print out latest beacon data.
  void Print();

  /// Print the latest FOV configuration
  int PrintFOV();

  /// Print the latest geometry configuration
  int PrintGeometry();

  /// Get the sensor's geometry configuration
  int GetConfigure();
 
  /// Get the field of view 
  int GetFOV();

  /** Set the field of view, updating the proxy with the actual values
      achieved. Params are: minimum range in meters, maximum range in
      meters, view angle in radians 
  */
  
  int SetFOV( double min_range, 
	      double max_range, 
	      double view_angle);
  
  /**  Attempt to send a message to a fiducial. See the Player manual
       for details of the message packet. Use a target_id of -1 to
       broadcast. If consume is true, the message is sent only
       once. If false, the message may be sent multiple times, but
       this is device dependent. Note: these message functions use
       configs that are probably only supported by Stage-1.4 (or
       later) fiducial driver.
  */

  int SendMessage( player_fiducial_msg_t* msg, bool consume );
  
  /* Read a message received by the device. If a message is available,
     the recv_msg packet is filled in and 0 is returned.  no message can
     be retrieved from the device, returns -1. If consume is true, the
     message is deleted from the device on reading. If false, the
     message is kept and can be read again. Note: these message
     functions use configs that are probably only supported by Stage-1.4
     (or later) fiducial driver.
  */

  int RecvMessage( player_fiducial_msg_t* msg, bool consume );

};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section LaserProxy
 *****************************************************************************/

/** The {\tt LaserProxy} class is used to control a {\tt laser}
device.  The latest scan data is held in two arrays: {\tt ranges} and
{\tt intensity}.  The laser scan range, resolution and so on can be
configured using the {\tt Configure()} method.  */
class LaserProxy : public ClientProxy
{

  public:

    /// Number of points in scan
    int scan_count;

    /** Angular resolution of scan (radians)
     */
    double scan_res;

    /** Scan range for the latest set of data (radians)
     */
    double min_angle, max_angle;
    
    /// Range resolution of scan (mm)
    double range_res;

    /// Whether or not reflectance (i.e., intensity) values are being returned.
    bool intensity;

    /// Scan data (polar): range (m) and bearing (radians)
    double scan[PLAYER_LASER_MAX_SAMPLES][2];

    /// Scan data (Cartesian): x,y (m)
    double point[PLAYER_LASER_MAX_SAMPLES][2];

    // TODO: haven't verified that intensities work yet:
    /// The reflected intensity values (arbitrary units in range 0-7).
    unsigned char intensities[PLAYER_LASER_MAX_SAMPLES];

    double min_right,min_left;
   
    /** Constructor.  Leave the access field empty to start
        unconnected. */
    LaserProxy(PlayerClient* pc, unsigned short index, 
               unsigned char access='c') :
        ClientProxy(pc,PLAYER_LASER_CODE,index,access) {}

    // these methods are the user's interface to this device

    /** Enable/disable the laser.
      Set {\tt state} to 1 to enable, 0 to disable.
      Note that when laser is disabled the client will still receive laser
      data, but the ranges will always be the last value read from the
      laser before it was disabled.
      Returns 0 on success, -1 if there is a problem.\\
      {\bf Note}: The {\tt sicklms200} driver currently does not implement
      this feature.
     */
    int SetLaserState(const unsigned char state);

    /** Configure the laser scan pattern.  Angles {\tt min\_angle} and
        {\tt max\_angle} are measured in radians.
        {\tt scan_res} is measured in units of $0.01^{\circ}$;
        valid values are: 25 ($0.25^{\circ}$), 50 ($0.5^{\circ}$) and
        $100 (1^{\circ}$).  {\tt range_res} is measured in mm; valid values
        are: 1, 10, 100.  Set {\tt intensity} to {\tt true} to
        enable intensity measurements, or {\tt false} to disable.
        Returns the 0 on success, or -1 of there is a problem.  
     */
    int Configure(double min_angle, 
                  double max_angle, 
                  unsigned int scan_res,
                  unsigned int range_res, 
                  bool intensity);

    /** Get the current laser configuration; it is read into the
        relevant class attributes. Returns the 0 on success, or -1
        of there is a problem.  */
    int GetConfigure();

    /// Get the number of range/intensity readings.
    int RangeCount() { return scan_count; }

    /// An alternate way to access the range data.
    double Ranges (int index)
    {
      if (index < scan_count)
        return scan[index][0];
      else
        return 0;
    }
    double MinLeft () { return min_left; }
    double MinRight () { return min_right; }

    /** Range access operator.  This operator provides an alternate
        way of access the range data.  For example, given an {\tt
        LaserProxy} named {\tt lp}, the following expressions are
        equivalent: \verb+lp.ranges[0]+, \verb+lp.Ranges(0)+, 
        and \verb+lp[0]+.  */
    double operator [] (unsigned int index)
    {
      return Ranges(index);
    }
    
    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out the current configuration and laser range/intensity data.
    void Print();

    /// Print out the current configuration
    void PrintConfig();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

#define MAX_RX_BUF_SIZE 1024


/*****************************************************************************
 ** begin section LocalizeProxy
 *****************************************************************************/

class localize_hypoth
{
  public:
    // Pose estimate (m, m, radians)
    double mean[3];
    // Covariance (m^2, radians^2)
    double cov[3][3];
    // Weight associated with this hypothesis
    double weight;
};

/** The {\tt LocalizeProxy} class is used to control a {\tt localize} device,
    which can provide multiple pose hypotheses for a robot.
 */
class LocalizeProxy : public ClientProxy
{

  public:
    /// Map dimensions (cells)
    unsigned int map_size_x, map_size_y;

    /// Map scale (m/cell)
    double map_scale;

    /// Map data (empty = -1, unknown = 0, occupied = +1)
    int8_t *map_cells;

    /// Number of pending (unprocessed) sensor readings
    int pending_count;
    
    /// Number of possible poses
    int hypoth_count;

    /** Array of possible poses.  Each pose contains the following
        information:
        \begin{itemize}
        \item {\tt double mean[3]} (pose estimate, in m, m, radians)
        \item {\tt double cov[3][3]} (covariance, in m$^{2}$ and radians$^{2}$)
        \item {\tt double weight} (weight associated with this estimate)
        \end{itemize}
     */
    localize_hypoth hypoths[PLAYER_LOCALIZE_MAX_HYPOTHS];


    /** Constructor.
        Leave the access field empty to start unconnected.
     */
    LocalizeProxy(PlayerClient* pc, unsigned short index, 
                  unsigned char access = 'c') :
            ClientProxy(pc,PLAYER_LOCALIZE_CODE,index,access)
    { map_cells=NULL; bzero(&hypoths,sizeof(hypoths)); }

    ~LocalizeProxy();

    // these methods are the user's interface to this device
    
    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);

    /** Set the current pose hypothesis (m, m, radians).  Returns 0 on 
        success, -1 on error.
     */
    int SetPose(double pose[3], double cov[3][3]);

    /** Get the number of particles (for particle filter-based localization
        systems).  Returns the number of particles, or -1 on error.
     */
    int GetNumParticles();

    /** Get the map from the server.  It's stored in map_size_x, map_size_y,
        map_scale, and map_cells.  Returns 0 on success, -1 on error.
     */
    int GetMap();
    
    /// Print out current hypotheses.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PositionProxy
 *****************************************************************************/

/** The {\tt PositionProxy} class is used to control a {\tt position} device.
    The latest position data is contained in the attributes {\tt xpos, ypos}, 
    etc.
 */
class PositionProxy : public ClientProxy
{

  public:
  /// Robot pose (according to odometry) in m, m, radians.
  double xpos,ypos,theta;

  /// Robot speeds in m/sec, m/sec, radians/sec.
  double speed, sidespeed, turnrate;

  /// Stall flag: 1 if the robot is stalled and 0 otherwise.
  unsigned char stall;
   
  /** Constructor.
      Leave the access field empty to start unconnected. */
  PositionProxy(PlayerClient* pc, unsigned short index,
                unsigned char access ='c') :
    ClientProxy(pc,PLAYER_POSITION_CODE,index,access) {}

  // these methods are the user's interface to this device

  /** Send a motor command for velocity control mode.
      Specify the forward, sideways, and angular speeds in m/sec, m/sec,
      and radians/sec, respectively.  Returns: 0 if everything's ok, 
      -1 otherwise.
  */
  int SetSpeed(double speed, double sidespeed, double turnrate);

  /** Same as the previous SetSpeed(), but doesn't take the sideways speed 
      (so use this one for non-holonomic robots). */
  int SetSpeed(double speed, double turnrate)
      { return(SetSpeed(speed,0.0,turnrate));}

  /** Send a motor command for position control mode.  Specify the
      desired pose of the robot in m, m, radians. Returns: 0 if
      everything's ok, -1 otherwise.  
  */
  int GoTo(double x, double y, double t);


  /** Enable/disable the motors.
      Set {\tt state} to 0 to disable or 1 to enable.
      Be VERY careful with this method!  Your robot is likely to run across the
      room with the charger still attached.
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int SetMotorState(unsigned char state);
    
  /** Select velocity control mode.
  
      For the the p2os_position driver, set {\tt mode} to 0 for direct wheel 
      velocity control (default), or 1 for separate translational and 
      rotational control.\\
      For the reb_position driver: 0 is direct velocity control, 1 is for 
      velocity-based heading PD controller (uses DoDesiredHeading()).\\
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int SelectVelocityControl(unsigned char mode);
   
  /** Reset odometry to (0,0,0).
      Returns: 0 if everything's ok, -1 otherwise.
  */
  int ResetOdometry();

  // the following ioctls are currently only supported by reb_position
  //

  /** Select position mode on the reb_position driver.
      Set {\tt mode} for 0 for velocity mode, 1 for position mode.
      Returns: 0 if OK, -1 else
  */
  int SelectPositionMode(unsigned char mode);

  /** Sets the odometry to the pose {\tt (x, y, theta)}.
      Note that {\tt x} and {\tt y} are in m and {\tt theta} is in radians.
      Returns: 0 if OK, -1 else
  */
  int SetOdometry(double x, double y, double t);

  /// Only supported by the reb_position driver.
  int SetSpeedPID(int kp, int ki, int kd);

  /// Only supported by the reb_position driver.
  int SetPositionPID(short kp, short ki, short kd);

  /// Only supported by the reb_position driver.
  int SetPositionSpeedProfile(short spd, short acc);

  /// Only supported by the reb_position driver.
  int DoStraightLine(int mm);

  /// Only supported by the reb_position driver.
  int DoRotation(int deg);

  /// Only supported by the reb_position driver.
  int DoDesiredHeading(int theta, int xspeed, int yawspeed);

  /// Only supported by the segwayrmp driver
  int SetStatus(uint8_t cmd, uint16_t value);

  /// Only supported by the segwayrmp driver
  int PlatformShutdown();

  /// Accessor method
  double  Xpos () const { return xpos; }
  
  /// Accessor method
  double  Ypos () const { return ypos; }
  
  /// Accessor method
  double Theta () const { return theta; }
  
  /// Accessor method
  double  Speed () const { return speed; }

  /// Accessor method
  double  SideSpeed () const { return sidespeed; }

  /// Accessor method
  double  TurnRate () const { return turnrate; }
  
  /// Accessor method
  unsigned char Stall () const { return stall; }

  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print current position device state.
  void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section Position3DProxy
 *****************************************************************************/

/** The {\tt Position3DProxy} class is used to control a {\tt position3d} 
    device.  The latest position data is contained in the attributes 
    {\tt xpos, ypos}, etc.
 */
class Position3DProxy : public ClientProxy
{

  public:
  /// Robot pose (according to odometry) in m, radians.
  double xpos,ypos,zpos;
  double roll,pitch,yaw;

  /// Robot speeds in m/sec, rad/sec
  double xspeed, yspeed, zspeed;
  double rollspeed, pitchspeed, yawspeed;

  /// Stall flag: 1 if the robot is stalled and 0 otherwise.
  unsigned char stall;
   
  /** Constructor.
      Leave the access field empty to start unconnected. */
  Position3DProxy(PlayerClient* pc, unsigned short index,
                  unsigned char access ='c') :
    ClientProxy(pc,PLAYER_POSITION3D_CODE,index,access) {}

  // these methods are the user's interface to this device

  /** Send a motor command for a planar robot.
      Specify the forward, sideways, and angular speeds in mm/s, mm/s,
      and degrees/sec, respectively.  Returns: 0 if everything's ok, 
      -1 otherwise.
  */
  int SetSpeed(double xspeed, double yspeed, double yawspeed);
  int SetSpeed(double xspeed, double yspeed, double zspeed, double yawspeed);
  /** Same as the previous SetSpeed(), but doesn't take the sideways speed 
      (so use this one for non-holonomic robots). */
  int SetSpeed(double xspeed, double yawspeed)
      { return(SetSpeed(xspeed,0.0,yawspeed));}

  /** Enable/disable the motors */
  int SetMotorState(unsigned char state);

  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print current position device state.
  void Print();

  /// Accessor method
  double  Xpos() const { return xpos; }
  
  /// Accessor method
  double  Ypos() const { return ypos; }
  
  /// Accessor method
  double  Zpos() const { return zpos; }
  
  /// Accessor method
  double  Roll() const { return roll; }
  
  /// Accessor method
  double  Pitch() const { return pitch; }
  
  /// Accessor method
  double  Yaw() const { return yaw; }
  
  /// Accessor method
  double  XSpeed() const { return xspeed; }

  /// Accessor method
  double  YSpeed() const { return yspeed; }

  /// Accessor method
  double  ZSpeed() const { return zspeed; }

  /// Accessor method
  double  RollSpeed() const { return rollspeed; }

  /// Accessor method
  double  PitchSpeed() const { return pitchspeed; }

  /// Accessor method
  double  YawSpeed() const { return yawspeed; }

  /// Accessor method
  unsigned char Stall () const { return stall; }
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PtzProxy
 *****************************************************************************/

/** The {\tt PtzProxy} class is used to control a {\tt ptz} device.
    The state of the camera can be read from the {\tt pan, tilt, zoom}
    attributes and changed using the {\tt SetCam()} method.
 */
class PtzProxy : public ClientProxy
{
  public:
    
    /// Pan, tilt, and field of view values (all radians).
    double pan, tilt, zoom;
    /// Pan and tilt speeds (rad/sec)
    double panspeed, tiltspeed;

    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    PtzProxy(PlayerClient* pc, unsigned short index, 
             unsigned char access='c') :
            ClientProxy(pc,PLAYER_PTZ_CODE,index,access) {}

    // these methods are the user's interface to this device

    /** Change the camera state.
        Specify the new {\tt pan}, {\tt tilt}, and {\tt zoom} values 
        (all degrees).
        Returns: 0 if everything's ok, -1 otherwise.
    */
    int SetCam(double pan, double tilt, double zoom);

    /** Specify new target velocities */
    int SetSpeed(double panspeed, double tiltspeed);

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Send a camera-specific config
    int SendConfig(uint8_t *bytes, size_t len, uint8_t *reply = NULL, 
                   size_t reply_len = 0);
    
    /** Select new control mode.  Use either PLAYER_PTZ_POSITION_CONTROL
        or PLAYER_PTZ_VELOCITY_CONTROL. */
    int SelectControlMode(uint8_t mode);

    /// Print out current ptz state.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section SonarProxy
 *****************************************************************************/

/** The {\tt SonarProxy} class is used to control a {\tt sonar} device.
    The most recent sonar range measuremts can be read from the {\tt range}
    attribute, or using the the {\tt []} operator.
 */
class SonarProxy : public ClientProxy
{

  public:
    /** The number of sonar readings received.
     */
    unsigned short range_count;

    /** The latest sonar scan data.
        Range is measured in m.
     */
    double ranges[PLAYER_SONAR_MAX_SAMPLES];

    /** Number of valid sonar poses
     */
    int pose_count;

    /** Sonar poses (m,m,radians)
     */
    double poses[PLAYER_SONAR_MAX_SAMPLES][3];
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    SonarProxy(PlayerClient* pc, unsigned short index, 
               unsigned char access = 'c') :
            ClientProxy(pc,PLAYER_SONAR_CODE,index,access)
    { 
      memset(&poses,0,sizeof(poses)); 
      range_count=pose_count=0;
    }

    // these methods are the user's interface to this device
    
    /** Enable/disable the sonars.
        Set {\tt state} to 1 to enable, 0 to disable.
        Note that when sonars are disabled the client will still receive sonar
        data, but the ranges will always be the last value read from the sonars
        before they were disabled.\\
        Returns 0 on success, -1 if there is a problem.
     */
    int SetSonarState(unsigned char state);

    /// Request the sonar geometry.
    int GetSonarGeom();

    /** Range access operator.
        This operator provides an alternate way of access the range data.
        For example, given a {\tt SonarProxy} named {\tt sp}, the following
        expressions are equivalent: \verb+sp.ranges[0]+ and \verb+sp[0]+.
     */
    double operator [](unsigned int index) 
    { 
      if(index < sizeof(ranges))
        return(ranges[index]);
      else 
        return(0);
    }

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current sonar range data.
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section SpeechProxy
 *****************************************************************************/

/** The {\tt SpeechProxy} class is used to control a
    {\tt speech} device.  Use the {\tt say} method to send things to say.
*/
class SpeechProxy : public ClientProxy
{

  public:
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    SpeechProxy(PlayerClient* pc, unsigned short index, 
                unsigned char access='c') :
            ClientProxy(pc,PLAYER_SPEECH_CODE,index,access) {}

    // these methods are the user's interface to this device

    /** Send a phrase to say.
        The phrase is an ASCII string.
        Returns the 0 on success, or -1 of there is a problem.
    */
    int Say(char* str);
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section TruthProxy
 *****************************************************************************/

/** The {\tt TruthProxy} gets and sets the {\em true} pose of a truth
    device [worldfile tag: truth()]. This may be different from the
    pose returned by a device such as GPS or Position. If you want to
    log what happened in an experiment, this is the device to
    use. 

    Setting the position of a truth device moves its parent, so you
    can put a truth device on robot and teleport it around the place. 
 */
class TruthProxy : public ClientProxy
{
  
  public:

  /** These vars store the current device pose (x,y,a) as
      (m,m,radians). The values are updated at regular intervals as
      data arrives. You can read these values directly but setting
      them does NOT change the device's pose!. Use {\tt
      TruthProxy::SetPose()} for that.  */
  double x, y, a; 

  /** Constructor.
      Leave the access field empty to start unconnected.  */
  TruthProxy(PlayerClient* pc, unsigned short index, 
             unsigned char access = 'c') :
    ClientProxy(pc,PLAYER_TRUTH_CODE,index,access) {};

    
  // interface that all proxies must provide
  void FillData(player_msghdr_t hdr, const char* buffer);
    
  /// Print out current pose info in a format suitable for data logging.
  void Print();

  /** Query Player about the current pose - requests the pose from the
      server, then fills in values for the arguments
      (m,m,radians). Usually you'll just read the {\tt x,y,a}
      attributes but this function allows you to get pose direct from
      the server if you need too. Returns 0 on success, -1 if there is
      a problem.  
  */
  int GetPose( double *px, double *py, double *pa );

  /** Request a change in pose (m,m,radians). Returns 0 on success, -1
      if there is a problem.  
  */
  int SetPose( double px, double py, double pa );

  /** ???
   */
  int SetPoseOnRoot( double px, double py, double pa );

  /** Request the value returned by a fiducialfinder (and possibly a
      foofinser, depending on its mode), when detecting this
      object. */
  int GetFiducialID( int16_t* id );

  /** Set the value returned by a fiducialfinder (and possibly a
      foofinser, depending on its mode), when detecting this
      object. */
  int SetFiducialID( int16_t id );

};


/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section BlobfinderProxy
 *****************************************************************************/

class Blob
{
  public:
    unsigned int color;
    unsigned int area;
    unsigned short x;
    unsigned short y;
    unsigned short left;
    unsigned short right;
    unsigned short top;
    unsigned short bottom;
    double range;
};


/** The {\tt BlobfinderProxy} class is used to control a {\tt blobfinder} 
    device.  It contains no methods.  The latest color blob data is stored in
    {\tt blobs}, a dynamically allocated 2-D array, indexed by color
    channel.
*/
class BlobfinderProxy : public ClientProxy
{

  public:
    
    /// Dimensions of the camera image, in pixels
    unsigned short width, height;

    /** Array containing the number of blobs detected on each channel 
     */ 
    char num_blobs[PLAYER_BLOBFINDER_MAX_CHANNELS];

    /** Array containing arrays of the latest blob data.
        Each blob contains the following information:
        \begin{itemize}
        \item {\tt unsigned int color} (in packed RGB)
        \item {\tt unsigned int area} (blob area, in square pixels)
        \item {\tt unsigned short x, y} (blob center, in pixels)
        \item {\tt unsigned short left, right, top, bottom} (blob bounding box,
        in pixels)
        \item {\tt double range} (range to blob center, in m)
        \end{itemize}
        For example, to access the area of the $0^{th}$ blob on channel 2, you
        would refer to: {\tt blobs[2][0].area}.
     */
    Blob* blobs[PLAYER_BLOBFINDER_MAX_CHANNELS];
   
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    BlobfinderProxy(PlayerClient* pc, unsigned short index, 
                unsigned char access='c');
    ~BlobfinderProxy();

    // these methods are the user's interface to this device

    // interface that all proxies must provide
    void FillData(player_msghdr_t hdr, const char* buffer);
    
    /// Print out current blob information.
    void Print();

    int SetTrackingColor();
    int SetTrackingColor(int rmin, int rmax, int gmin,
                         int gmax, int bmin, int bmax);
    int SetImagerParams(int contrast, int brightness,
                         int autogain, int colormode);
    int SetContrast(int c);
    int SetColorMode(int m);
    int SetBrightness(int b);
    int SetAutoGain(int g);
;
};


/*****************************************************************************
 ** end section
 *****************************************************************************/


// these define default coefficients for our 
// range and standard deviation estimates
#define IRPROXY_DEFAULT_DIST_M_VALUE -0.661685227
#define IRPROXY_DEFAULT_DIST_B_VALUE  10.477102515

#define IRPROXY_DEFAULT_STD_M_VALUE  1.913005560938
#define IRPROXY_DEFAULT_STD_B_VALUE -7.728130591833

#define IRPROXY_M_PARAM 0
#define IRPROXY_B_PARAM 1

//this is the effective range of the sensor in mm
#define IRPROXY_MAX_RANGE 700

/*****************************************************************************
 ** begin section IRProxy
 *****************************************************************************/

/** The {\tt IRProxy} class is used to control an {\tt ir} device.   Right
    now, it is particular to the {\tt reb_ir} driver.
 */
class IRProxy : public ClientProxy
{
public:

  /// Latest range readings
  unsigned short ranges[PLAYER_IR_MAX_SAMPLES];
  
  /// Latest voltage readings
  unsigned short voltages[PLAYER_IR_MAX_SAMPLES];

  /// Standard deviations
  double stddev[PLAYER_IR_MAX_SAMPLES];

  /// Distance regression params
  double params[PLAYER_IR_MAX_SAMPLES][2]; 

  /// Standard deviation regression params
  double sparams[PLAYER_IR_MAX_SAMPLES][2]; 

  /** Poses of the IRs.  Contains:
      \begin{itemize}
      \item short poses[PLAYER_IR_MAX_SAMPLES][3];
      \end{itemize}
      Where each pose element contains: (x,y,theta) in (mm,mm,degrees). */
  player_ir_pose_t ir_pose;

    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  IRProxy(PlayerClient *pc, unsigned short index,
          unsigned char access = 'c');

  /// Enable/disable the IRs.
  int SetIRState(unsigned char state);

  /// Request the poses of the IRs.
  int GetIRPose();

  /// Set range parameters.
  void SetRangeParams(int which, double m, double );

  /// Set standard deviation parameters.
  void SetStdDevParams(int which, double m, double b);

  /// Calculate standard deviations.
  double CalcStdDev(int w, unsigned short range);

    /** Range access operator.
        This operator provides an alternate way of access the range data.
        For example, given a {\tt IRProxy} named {\tt ip}, the following
        expressions are equivalent: \verb+ip.ranges[0]+ and \verb+ip[0]+.
     */
  unsigned short operator [](unsigned int index) 
  {
    if (index < PLAYER_IR_MAX_SAMPLES) {
      return ranges[index];
    } 

    return 0;
  }

  // required methods
  void FillData(player_msghdr_t hdr, const char *buffer);

  /// Print out current IR data.
  void Print();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section WiFiProxy
 *****************************************************************************/

/** The {\tt WiFiProxy} class controls a {\tt wifi} device.
 */
class WiFiProxy: public ClientProxy
{
public:


    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  WiFiProxy(PlayerClient *pc, unsigned short index, 
	       unsigned char access = 'c') :
    ClientProxy(pc, PLAYER_WIFI_CODE, index, access), link_count(0) {}


  int GetLinkQuality(char * ip = NULL);
  int GetLevel(char * ip = NULL);
  int GetLeveldBm(char * ip = NULL) { return GetLevel(ip) - 0x100; }
  int GetNoise(char * ip = NULL);
  int GetNoisedBm(char * ip = NULL) { return GetNoise(ip) - 0x100; }

  uint16_t GetMaxLinkQuality() { return maxqual; }
  uint8_t GetMode() { return op_mode; }

  int GetBitrate();

  char * GetMAC(char *buf, int len);

  char * GetIP(char *buf, int len);
  char * GetAP(char *buf, int len);

  int AddSpyHost(char *address);
  int RemoveSpyHost(char *address);

  void FillData(player_msghdr_t hdr, const char *buffer);

  /// Print out current data.
  void Print();

protected:
  int GetLinkIndex(char *ip);

  /// The current wifi data.
  int link_count;
  player_wifi_link_t links[PLAYER_WIFI_MAX_LINKS];
  uint32_t throughput;
  uint8_t op_mode;
  int32_t bitrate;
  uint16_t qual_type, maxqual, maxlevel, maxnoise;
  
  char access_point[32];

};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section PowerProxy
 *****************************************************************************/

/** The {\tt PowerProxy} class controls a {\tt power} device.
 */
class PowerProxy : public ClientProxy 
{

  public:
    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    PowerProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c')
            : ClientProxy(pc,PLAYER_POWER_CODE,index,access) {}

    /// Returns the current charge.
    double Charge () const { return charge; }

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print the current data.
    void Print ();

  private:
    // Remaining power in volts
    double charge;
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section AudioProxy
 *****************************************************************************/

/** The {\tt AudioProxy} class controls an {\tt audio} device.
 */
class AudioProxy : public ClientProxy 
{

  public:
    /** Hz, db ? */
    uint16_t frequency0, amplitude0;
    /** Hz, db ? */
    uint16_t frequency1, amplitude1;
    /** Hz, db ? */
    uint16_t frequency2, amplitude2;
    /** Hz, db ? */
    uint16_t frequency3, amplitude3;
    /** Hz, db ? */
    uint16_t frequency4, amplitude4;

    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    AudioProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c')
            : ClientProxy(pc,PLAYER_AUDIO_CODE,index,access) {}

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Play a fixed-frequency tone
    int PlayTone(unsigned short freq, unsigned short amp, unsigned short dur);

    /// Print the current data.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section AudioDSPProxy
 *****************************************************************************/

/** The {\tt AudioDSPProxy} class controls an {\tt acoustics} device.
 */
class AudioDSPProxy : public ClientProxy 
{

  public:
    /** Format code of each sample */
    int16_t sampleFormat;

    /** Rate at which to sample (Hz) */
    uint16_t sampleRate;

    /** Number of channels */
    uint8_t channels;

    uint16_t freq[5];
    uint16_t amp[5];

    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    AudioDSPProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c')
            : ClientProxy(pc,PLAYER_AUDIODSP_CODE,index,access) {}

    int Configure(uint8_t channels, uint16_t sampleRate, 
        int16_t sampleFormat=0xFFFFFFFF );

    int GetConfigure();

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Play a fixed-frequency tone
    int PlayTone(unsigned short freq, unsigned short amp, unsigned int dur);
    int PlayChirp(unsigned short freq, unsigned short amp, unsigned int dur,
        const unsigned char bitString[], unsigned short bitStringLen);
    int Replay();

    /// Print the current data.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section AudioMixerProxy
 *****************************************************************************/

/** The {\tt AudioMixerProxy} class controls an {\tt mixer} device.
 */
class AudioMixerProxy : public ClientProxy 
{

  public:
    unsigned short masterLeft, masterRight;
    unsigned short pcmLeft, pcmRight;
    unsigned short lineLeft, lineRight;
    unsigned short micLeft, micRight;
    unsigned short iGain, oGain;

    /** Constructor.
      Leave the access field empty to start unconnected.
     */
    AudioMixerProxy (PlayerClient* pc, unsigned short index,
                unsigned char access ='c')
            : ClientProxy(pc,PLAYER_AUDIOMIXER_CODE,index,access) {}

    int GetConfigure();

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    int SetMaster(unsigned short left, unsigned short right);
    int SetPCM(unsigned short left, unsigned short right);
    int SetLine(unsigned short left, unsigned short right);
    int SetMic(unsigned short left, unsigned short right);
    int SetIGain(unsigned short gain);
    int SetOGain(unsigned short gain);

    // Print the current data.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section BumperProxy
 *****************************************************************************/

/** The {\tt BumperProxy} class is used to read from a {\tt bumper} device.
 */
class BumperProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    BumperProxy (PlayerClient* pc, unsigned short index,
                   unsigned char access = 'c')
            : ClientProxy(pc,PLAYER_BUMPER_CODE,index,access) 
      {}

    ~BumperProxy()
      {}

    // these methods are the user's interface to this device

    /** Returns 1 if the specified bumper has been bumped, 0 otherwise.
      */
    bool Bumped (const unsigned int i);

    /** Returns 1 if any bumper has been bumped, 0 otherwise.
      */
    bool BumpedAny ();

    /** Requests the geometries of the bumpers.
        Returns -1 if anything went wrong, 0 if OK
     */ 
    int GetBumperGeom( player_bumper_geom_t* bumper_defs );

    /// Returns the number of bumper readings.
    uint8_t BumperCount () const { return bumper_count; }

    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current bumper state.
    void Print ();

private:
    /** array representing bumped state.
     */
    uint8_t bumper_count;
    uint8_t bumpers[PLAYER_BUMPER_MAX_SAMPLES];
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section DIOProxy
 *****************************************************************************/

/** The {\tt DIOProxy} class is used to read from a {\tt dio} (digital I/O)
    device.
 */
class DIOProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
    DIOProxy (PlayerClient* pc, unsigned short index,
                   unsigned char access = 'c')
            : ClientProxy(pc,PLAYER_DIO_CODE,index,access) 
      {}

    ~DIOProxy()
      {}

    /// The number of valid digital inputs.
    char count;

    /// A bitfield of the current digital inputs.
    unsigned int digin;
    
    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current digital input state.
    void Print ();
};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section WaveformProxy
 *****************************************************************************/

/** The {\tt WaveformProxy} class is used to read raw digital
 waveforms from a device.  */
class WaveformProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  WaveformProxy (PlayerClient* pc, unsigned short index,
		 unsigned char access = 'c')
    : ClientProxy(pc,PLAYER_WAVEFORM_CODE,index,access) 
    {
      this->ConfigureDSP(); // use latest settings	
    }
  
  ~WaveformProxy();
  
    /// sample rate in bits per second
    unsigned int bitrate;

    /// sample depth in bits
    unsigned short depth;

    //// the number of samples in the most recent packet
    unsigned int last_samples;

    /// the data is buffered here for playback
    unsigned char buffer[PLAYER_WAVEFORM_DATA_MAX];
  
    /// dsp file descriptor
    int fd; 
  
    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current status
    void Print ();

    // set up the DSP to the current bitrate and depth
    int ConfigureDSP() ;

    // open the sound device 
    void OpenDSPforWrite();

    // Play the waveform through the DSP
    void Play();

};
/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section MComProxy
 *****************************************************************************/

/*  MComProxy class by Matt Brewer <mbrewer@andrew.cmu.edu> at 
 *  UMass Amherst 2002 (updated for player 1.3 by reed)
 */                      

// this is from the player server (server/drivers/mcom/ in the source tree)
//#include "player_mcom_types.h"

/** The {\tt MComProxy} class is used to exchange data with other clients
    connected with the same server, through a set of named "channels". 
    For some useful (but optional) type and constant definitions that you
    can use in your clients, see <playermcomtypes.h>.
 */
class MComProxy : public ClientProxy 
{

public:
    /** These members contain the results of the last command.
        Note: It's better to use the LastData() method. */   
    player_mcom_data_t data;
    int type;
    char channel[MCOM_CHANNEL_LEN];

public:
    MComProxy(PlayerClient* pc, unsigned short index, 
              unsigned char access = 'c') :
            ClientProxy(pc,PLAYER_MCOM_CODE,index,access){}

    /** Read and remove the most recent buffer in 'channel' with type 'type'.
        The result can be read with LastData() after the next call to 
        PlayerClient::Read().
        @return 0 if no error
        @return -1 on error, the channel does not exist, or the channel is empty.
    */
    int Pop(int type, char channel[MCOM_CHANNEL_LEN]);

    /** Read the most recent buffer in 'channel' with type 'type'.
        The result can be read with LastData() after the next call to
        PlayerClient::Read().
        @return 0 if no error
        @return -1 on error, the channel does not exist, or the channel is empty.
    */
    int Read(int type, char channel[MCOM_CHANNEL_LEN]);

    /** Push a message 'dat' into channel 'channel' with message type 'type'. */
    int Push(int type, char channel[MCOM_CHANNEL_LEN], char dat[MCOM_DATA_LEN]);

    /** Clear all messages of type 'type' on channel 'channel' */
    int Clear(int type, char channel[MCOM_CHANNEL_LEN]);

  /** Set the capacity of the buffer using 'type' and 'channel' to 'cap'.  
      Note that 'cap' is an unsigned char and must be < MCOM_N_BUFS */
  int SetCapacity(int type, char channel[MCOM_CHANNEL_LEN], unsigned char cap);

    /** Get the results of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    char* LastData() { return data.data; }

    /** Get the results of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    int LastMsgType() { return type; }

    /** Get the channel of the last command (Pop or Read). Call
        PlayerClient::Read() before using.  */
    char* LastChannel() { return channel; }

    void FillData(player_msghdr_t hdr, const char* buffer);
    void Print();
};

/*****************************************************************************
 ** end section
 *****************************************************************************/


/*****************************************************************************
 ** begin section BlinkenlightProxy
 *****************************************************************************/

/** The {\tt BlinkenlightProxy} class is used to enable and disable a
 flashing indicator light, and to set it's period. */
class BlinkenlightProxy : public ClientProxy 
{

public:
    /** Constructor.
        Leave the access field empty to start unconnected.
    */
  BlinkenlightProxy (PlayerClient* pc, unsigned short index,
		     unsigned char access = 'c')
    : ClientProxy(pc,PLAYER_BLINKENLIGHT_CODE,index,access) 
    {
      // assume the light is off by default
      this->period_ms = 0;
      this->enable = false;
    }
  
  virtual ~BlinkenlightProxy()
    { };
  
  /// true: indicator light enabled, false: disabled.
  bool enable;
  
  /** The current period (one whole on/off cycle) of the blinking
      light. If the period is zero and the light is enabled, the light
      is on. 
  */
  int period_ms;
  
    // interface that all proxies must provide
    void FillData (player_msghdr_t hdr, const char* buffer);

    /// Print out the current status
    void Print ();

    /** Set the state of the indicator light. A period of zero means
        the light will be unblinkingly on or off. Returns 0 on
        success, else -1.
    */
    int SetLight( bool enable, int period_ms );
};

/*****************************************************************************
 ** end section
 *****************************************************************************/

/*****************************************************************************
 ** begin section CameraProxy
 *****************************************************************************/

/** The {\tt CameraProxy} class can be used to get images from a camera. */

class CameraProxy : public ClientProxy 
{

public:
    // Constructor.  Leave the access field empty to start unconnected.
   CameraProxy (PlayerClient *pc, unsigned short index,
       unsigned char access='c');

   virtual ~CameraProxy();

   // Image color depth
   uint8_t depth;

   // Image dimensions (pixels)
   uint16_t width, height;

   // Sime of the image (bytes)
   uint32_t imageSize;

   // Image data
   uint8_t image[PLAYER_CAMERA_IMAGE_SIZE];

   // interface that all proxies must provide
   void FillData(player_msghdr_t hdr, const char* buffer);
};

/*****************************************************************************
 ** begin section HUDProxy
 *****************************************************************************/

/** The {\tt HUDProxy} class can be used to draw shapes onto a simulator
 * screen. All values for the Draw routines should be pixel values.*/

class HUDProxy : public ClientProxy 
{

public:
    // Constructor.  Leave the access field empty to start unconnected.
   HUDProxy (PlayerClient *pc, unsigned short index,
       unsigned char access='c');

   virtual ~HUDProxy();

   // Set the drawing color
   void SetColor( float color[3] );

   // Set the drawing style
   void SetStyle( int filled );

   // Remove the draw element with id
   int Remove(int id);

   // Draw a box, opposing corners defined by (ax,ay) and (bx,by)
   int DrawBox(int id, int ax, int ay, int bx, int by);

   // Draw a line on , end point define by (ax,ay) and (bx,by)
   int DrawLine(int id, int ax, int ay, int bx, int by);

   // Draw text at (x,y) 
   int DrawText(int id, const char *text, int x, int y);

   // Draw a circle, center defined  by (cx,cy) and radius (radius) 
   int DrawCircle(int id, int cx, int cy, int radius);


   // interface that all proxies must provide
   void FillData(player_msghdr_t hdr, const char* buffer);

private:
   float color[3];
   int filled;
};

#endif
